<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Kim Hung&#39;s ThinkStack</title>
<link>https://kimhungbui.github.io/programming.html</link>
<atom:link href="https://kimhungbui.github.io/programming.xml" rel="self" type="application/rss+xml"/>
<description>My Personal Website</description>
<generator>quarto-1.5.57</generator>
<lastBuildDate>Mon, 21 Jul 2025 00:00:00 GMT</lastBuildDate>
<item>
  <title>Project Euler Problem 54- Poker Hands</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/project-euler-54-poker-hands/</link>
  <description><![CDATA[ 




<section id="problem-overview" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Problem Overview</h1>
<p>In poker, hands are ranked from lowest to highest as follows:</p>
<ol type="1">
<li>High Card<br>
</li>
<li>One Pair<br>
</li>
<li>Two Pairs<br>
</li>
<li>Three of a Kind<br>
</li>
<li>Straight<br>
</li>
<li>Flush<br>
</li>
<li>Full House<br>
</li>
<li>Four of a Kind<br>
</li>
<li>Straight Flush<br>
</li>
<li>Royal Flush</li>
</ol>
<p>If both players have the same rank, then the highest card is used to break ties.</p>
<p>We are given a file <code>poker.txt</code> containing 1,000 hands. Each line has 10 cards (5 for Player 1 and 5 for Player 2). The task is to determine <strong>how many times Player 1 wins</strong>.</p>
</section>
<section id="intuition" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Intuition</h1>
<p>To solve this, we must: - Parse the file and separate the cards. - Evaluate the rank of each player’s hand. - Compare both hands. - Count the number of times Player 1 wins.</p>
</section>
<section id="approach" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Approach</h1>
<p>We will: 1. Create a value mapping for cards from <code>'2'</code> to <code>'A'</code>. 2. Implement a hand evaluation function that returns a tuple containing: - A numeric rank code (higher is better), - A tie-breaker list of card values. 3. Read the file line-by-line, split the hands, and apply the evaluation. 4. Use tuple comparison to determine the winner.</p>
</section>
<section id="full-python-implementation" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Full Python Implementation</h1>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> collections <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Counter</span>
<span id="cb1-2"></span>
<span id="cb1-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Step 1: Value mapping</span></span>
<span id="cb1-4">CARD_VALUES <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'2'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'3'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'4'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'5'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>,</span>
<span id="cb1-5">               <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'6'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">6</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'7'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'8'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'9'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">9</span>,</span>
<span id="cb1-6">               <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'T'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'J'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">11</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Q'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">12</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'K'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">13</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'A'</span>: <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">14</span>}</span>
<span id="cb1-7"></span>
<span id="cb1-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Step 2: Evaluate hand</span></span>
<span id="cb1-9"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> hand_rank(hand):</span>
<span id="cb1-10">    values <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sorted</span>([CARD_VALUES[c[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]] <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> c <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> hand], reverse<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb1-11">    suits <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [c[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> c <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> hand]</span>
<span id="cb1-12">    counts <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Counter(values)</span>
<span id="cb1-13">    count_vals <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sorted</span>(counts.items(), key<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">lambda</span> x: (<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>x[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>], <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>x[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]))</span>
<span id="cb1-14">    ordered_values <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [val <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> val, cnt <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> count_vals]</span>
<span id="cb1-15"></span>
<span id="cb1-16">    is_flush <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">set</span>(suits)) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb1-17">    is_straight <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> values <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">list</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(values[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>], values[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>))</span>
<span id="cb1-18"></span>
<span id="cb1-19">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> is_straight <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> is_flush:</span>
<span id="cb1-20">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span>, values)</span>
<span id="cb1-21">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> count_vals[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>][<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>:</span>
<span id="cb1-22">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>, ordered_values)</span>
<span id="cb1-23">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> count_vals[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>][<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> count_vals[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>][<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>:</span>
<span id="cb1-24">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">6</span>, ordered_values)</span>
<span id="cb1-25">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> is_flush:</span>
<span id="cb1-26">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>, values)</span>
<span id="cb1-27">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> is_straight:</span>
<span id="cb1-28">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>, values)</span>
<span id="cb1-29">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> count_vals[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>][<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>:</span>
<span id="cb1-30">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, ordered_values)</span>
<span id="cb1-31">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> count_vals[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>][<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> count_vals[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>][<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>:</span>
<span id="cb1-32">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, ordered_values)</span>
<span id="cb1-33">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> count_vals[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>][<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>:</span>
<span id="cb1-34">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, ordered_values)</span>
<span id="cb1-35">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb1-36">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> (<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, values)</span>
<span id="cb1-37"></span>
<span id="cb1-38"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Step 3: Compare two hands</span></span>
<span id="cb1-39"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> player1_wins(hand1, hand2):</span>
<span id="cb1-40">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> hand_rank(hand1) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> hand_rank(hand2)</span>
<span id="cb1-41"></span>
<span id="cb1-42"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Step 4: Process file</span></span>
<span id="cb1-43"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> count_player1_wins(filename<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'poker.txt'</span>):</span>
<span id="cb1-44">    count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb1-45">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">with</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">open</span>(filename) <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> f:</span>
<span id="cb1-46">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> line <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> f:</span>
<span id="cb1-47">            cards <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> line.strip().split()</span>
<span id="cb1-48">            hand1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> cards[:<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>]</span>
<span id="cb1-49">            hand2 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> cards[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>:]</span>
<span id="cb1-50">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> player1_wins(hand1, hand2):</span>
<span id="cb1-51">                count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb1-52">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> count</span>
<span id="cb1-53"></span>
<span id="cb1-54"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Step 5: Output result</span></span>
<span id="cb1-55"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(count_player1_wins())</span></code></pre></div>
</section>
<section id="complexity" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Complexity</h1>
<ul>
<li><p>Time Complexity: <img src="https://latex.codecogs.com/png.latex?N(N%5Clog%20N)"> per hand due to sorting, where <img src="https://latex.codecogs.com/png.latex?N=5">. Since it’s constant-sized, it is effectively <img src="https://latex.codecogs.com/png.latex?O(1)"> per hand. Processing 1,000 hands is <img src="https://latex.codecogs.com/png.latex?O(1,000)"> total.</p></li>
<li><p>Space Complexity: Also <img src="https://latex.codecogs.com/png.latex?O(1)"> per hand due to fixed size.</p></li>
</ul>
</section>
<section id="conclusion" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Conclusion</h1>
<p>This problem combines string parsing, sorting, and custom rule-based comparison logic. It’s an excellent example of how domain-specific logic (poker hand rules) can be embedded into structured programmatic comparisons.</p>
<p>You can adapt this solution to simulate poker games, build bots, or explore probability distributions of poker hands.</p>


</section>

 ]]></description>
  <guid>https://kimhungbui.github.io/programming/project-euler-54-poker-hands/</guid>
  <pubDate>Mon, 21 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Backtracking with Duplicate Skipping — Clean Solution to Combination Sum II</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-40-combination-sum-ii/</link>
  <description><![CDATA[ 




<section id="intuition" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Intuition</h1>
<p>The problem asks us to find <strong>unique combination</strong> that sum to a garget, but <strong>each number can be used only once</strong>. This immediately suggests a <strong>backtracking</strong> appoach - we explore combinations recursively and prune paths that exceed the target.</p>
<p>Because there may be <strong>duplicate numbers</strong> in the input, we need to <strong>skip duplicates at the same depth</strong> to avoid generating repeated combinations.</p>
</section>
<section id="approach" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Approach</h1>
<ol type="1">
<li><p>Sort the input to bring duplicates together and allow early stopping.</p></li>
<li><p>Use a backtracking finction to explore choices:</p>
<ul>
<li>Include current number</li>
<li>Recurse with the next index (i+1) to prevent resuing the same element</li>
</ul></li>
<li><p>At each rescursive call:</p>
<ul>
<li>if <code>total == target</code>, we’ve found a valid path - store it</li>
<li>if <code>total &gt; target</code>, stop this path</li>
<li>Skip current element if it’s a duplicate at the same recursion level.</li>
</ul></li>
</ol>
</section>
<section id="complexity" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Complexity</h1>
<ul>
<li><p>Time complexity: <img src="https://latex.codecogs.com/png.latex?O(2%5En)"> in the worst case, due to the number of combinations we exlore (through pruning and skipping duplicates improve this).</p></li>
<li><p>Space complexity: <img src="https://latex.codecogs.com/png.latex?O(n)"> for the rescursion call stack and current path.</p></li>
</ul>
</section>
<section id="code" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Code</h1>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> typing <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> List</span>
<span id="cb1-2"></span>
<span id="cb1-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Solution:</span>
<span id="cb1-4">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> combinationSum2(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, candidates: List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>], target: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> List[List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>]]:</span>
<span id="cb1-5">    candidates.sort()</span>
<span id="cb1-6"></span>
<span id="cb1-7">    result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb1-8">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> backtrack(start: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>, path: List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>], total: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>):</span>
<span id="cb1-9">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> total <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> target:</span>
<span id="cb1-10">            result.append(path[:])</span>
<span id="cb1-11">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span></span>
<span id="cb1-12">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> total <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> target:</span>
<span id="cb1-13">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span></span>
<span id="cb1-14"></span>
<span id="cb1-15">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(start, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(candidates)):</span>
<span id="cb1-16">            cur <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> candidates[i]</span>
<span id="cb1-17"></span>
<span id="cb1-18">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># skip duplicates at the same depth level</span></span>
<span id="cb1-19">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> cur <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> prev:</span>
<span id="cb1-20">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">continue</span></span>
<span id="cb1-21">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> total <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> cur <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> target:</span>
<span id="cb1-22">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">break</span></span>
<span id="cb1-23"></span>
<span id="cb1-24">            path.append(cur)</span>
<span id="cb1-25">            backtrack(i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, path, total <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> cur)</span>
<span id="cb1-26">            path.pop()</span>
<span id="cb1-27">            prev <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> cur</span>
<span id="cb1-28"></span>
<span id="cb1-29">    backtrack(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, [], <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>)</span>
<span id="cb1-30">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> result</span></code></pre></div>


</section>

 ]]></description>
  <category>backtracking</category>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-40-combination-sum-ii/</guid>
  <pubDate>Mon, 21 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Combinatoric Selections</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/project-euler-53/</link>
  <description><![CDATA[ 




<section id="problem" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Problem</h1>
<p>
There are exactly ten ways of selecting three from five, 12345:
</p>
<p class="center">
123, 124, 125, 134, 135, 145, 234, 235, 245, and 345
</p>
<p>
In combinatorics, we use the notation, <img src="https://latex.codecogs.com/png.latex?%5Cdisplaystyle%20%5Cbinom%205%203%20=%2010">.
</p>
<p>
In general, <img src="https://latex.codecogs.com/png.latex?%5Cdisplaystyle%20%5Cbinom%20n%20r%20=%20%5Cdfrac%7Bn!%7D%7Br!(n-r)!%7D">, where <img src="https://latex.codecogs.com/png.latex?r%20%5Cle%20n">, <img src="https://latex.codecogs.com/png.latex?n!%20=%20n%20%5Ctimes%20(n-1)%20%5Ctimes%20...%20%5Ctimes%203%20%5Ctimes%202%20%5Ctimes%201">, and <img src="https://latex.codecogs.com/png.latex?0!%20=%201">.
</p>
<p>
It is not until <img src="https://latex.codecogs.com/png.latex?n%20=%2023">, that a value exceeds one-million: <img src="https://latex.codecogs.com/png.latex?%5Cdisplaystyle%20%5Cbinom%20%7B23%7D%20%7B10%7D%20=%201144066">.
</p>
<p>
How many, not necessarily distinct, values of <img src="https://latex.codecogs.com/png.latex?%5Cdisplaystyle%20%5Cbinom%20n%20r"> for <img src="https://latex.codecogs.com/png.latex?1%20%5Cle%20n%20%5Cle%20100">, are greater than one-million?
</p>


</section>

 ]]></description>
  <category>project-euler</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/project-euler-53/</guid>
  <pubDate>Sat, 19 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Merge Triplets to Form Target Triplet</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-triplet/</link>
  <description><![CDATA[ 




<section id="intuition" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Intuition</h1>
<p>We aim to form the target triplet <code>[x, y, z]</code> by merging valid triplets using element-wise maximums. A key observation is that any triplet with a value exceeding the target in any dimension cannot be used. Therefore, we filter those out and search for triplets that can contribute exactly <code>x</code>, <code>y</code>, or <code>z</code> without exceeding the other target dimensions.</p>
</section>
<section id="approach" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Approach</h1>
<ol type="1">
<li>Initialize three boolean flags: <code>found_x</code>, <code>found_y</code>, and <code>found_z</code> to track whether we have found triplets that can provide <code>x</code>, <code>y</code>, and <code>z</code> respectively.</li>
<li>Iterate through each triplet:
<ul>
<li>Skip the triplet if any of its elements exceed the target at the corresponding index.</li>
<li>If the triplet is valid:
<ul>
<li>If <code>triplet[0] == x</code>, mark <code>found_x = True</code></li>
<li>If <code>triplet[1] == y</code>, mark <code>found_y = True</code></li>
<li>If <code>triplet[2] == z</code>, mark <code>found_z = True</code></li>
</ul></li>
</ul></li>
<li>After iterating through all triplets, if all three flags are <code>True</code>, return <code>True</code>; otherwise, return <code>False</code>.</li>
</ol>
<p>This approach is greedy because we only care about finding at least one valid triplet that satisfies each coordinate condition individually.</p>
</section>
<section id="complexity" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Complexity</h1>
<ul>
<li><p>Time complexity:<br>
<img src="https://latex.codecogs.com/png.latex?O(n)"><br>
We iterate over the list of triplets once, performing constant-time operations per triplet.</p></li>
<li><p>Space complexity:<br>
<img src="https://latex.codecogs.com/png.latex?O(1)"><br>
We only use three boolean variables and no additional data structures.</p></li>
</ul>
<section id="problem-summary-merge-triplets-to-form-target-triplet" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="problem-summary-merge-triplets-to-form-target-triplet"><span class="header-section-number">3.1</span> Problem Summary: Merge Triplets to Form Target Triplet</h2>
<p>We are given: - A list of triplets: each is [a, b, c] - A target triplet: [x, y, z]</p>
<p>Our task is to <strong>merge</strong> some of the triplets to form the target triplet, using this rule:</p>
<section id="merge-rule" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="merge-rule"><span class="header-section-number">3.1.1</span> Merge Rule:</h3>
<p>Merging two triplets means taking the element-wise maximum:</p>
<pre><code>[a1, b1, c1] + [a2, b2, c2] = [max(a1, a2), max(b1, b2), max(c1, c2)]</code></pre>
<p>But we can <strong>only use</strong> a triplet if it satisfies:</p>
<pre><code>triplet[i] ≤ target[i] for all i in {0, 1, 2}</code></pre>
<p>We must decide if it’s possible to form the target triplet through a sequence of such merges.</p>
<hr>
</section>
</section>
<section id="step-by-step-solution-strategy-greedy" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="step-by-step-solution-strategy-greedy"><span class="header-section-number">3.2</span> Step-by-step Solution Strategy (Greedy)</h2>
<section id="step-1-filter-valid-triplets" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="step-1-filter-valid-triplets"><span class="header-section-number">3.2.1</span> Step 1: Filter Valid Triplets</h3>
<p>We first discard any triplet that has a value greater than the target at any position:</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> x <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">or</span> b <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> y <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">or</span> c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> z:</span>
<span id="cb3-2">    skip this triplet</span></code></pre></div>
<p>These triplets cannot be used in any valid merge.</p>
<hr>
</section>
<section id="step-2-identify-building-blocks" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="step-2-identify-building-blocks"><span class="header-section-number">3.2.2</span> Step 2: Identify Building Blocks</h3>
<p>We are trying to “build” each of the three elements of the target.</p>
<p>That means we must find at least one triplet that contributes to: - <code>a == x</code> - <code>b == y</code> - <code>c == z</code></p>
<p>For example: - A triplet like [x, ≤y, ≤z] helps construct the first coordinate - A triplet like [≤x, y, ≤z] helps the second - A triplet like [≤x, ≤y, z] helps the third</p>
<p>We can mix triplets to form the full target.</p>
<hr>
</section>
<section id="step-3-greedy-tracking" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="step-3-greedy-tracking"><span class="header-section-number">3.2.3</span> Step 3: Greedy Tracking</h3>
<p>We initialize flags:</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1">found_x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> found_y <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> found_z <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span></span></code></pre></div>
<p>Then iterate through all <strong>valid</strong> triplets:</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> triplet <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> triplets:</span>
<span id="cb5-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> x <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> y <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> z:</span>
<span id="cb5-3">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> x:</span>
<span id="cb5-4">            found_x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span></span>
<span id="cb5-5">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> y:</span>
<span id="cb5-6">            found_y <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span></span>
<span id="cb5-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> z:</span>
<span id="cb5-8">            found_z <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span></span></code></pre></div>
<hr>
</section>
<section id="step-4-final-decision" class="level3" data-number="3.2.4">
<h3 data-number="3.2.4" class="anchored" data-anchor-id="step-4-final-decision"><span class="header-section-number">3.2.4</span> Step 4: Final Decision</h3>
<p>If all three components are found:</p>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> found_x <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> found_y <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> found_z:</span>
<span id="cb6-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span></span>
<span id="cb6-3"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb6-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span></span></code></pre></div>
<hr>
</section>
</section>
<section id="example" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="example"><span class="header-section-number">3.3</span> Example</h2>
<p>Given:</p>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1">triplets <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>], [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>], [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>]]</span>
<span id="cb7-2">target <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>]</span></code></pre></div>
<ul>
<li>[2,5,3] is valid: helps with x=2 and y=5</li>
<li>[1,8,4] is invalid: 8 &gt; 5</li>
<li>[2,3,5] is valid: helps with x=2 and z=5</li>
</ul>
<p>We found: - x: yes (from both) - y: yes (from [2,5,3]) - z: yes (from [2,3,5])</p>
<p>Return: <code>True</code></p>
<hr>
</section>
<section id="why-it-is-a-greedy-problem" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="why-it-is-a-greedy-problem"><span class="header-section-number">3.4</span> Why It Is a Greedy Problem</h2>
<p>We make <strong>local greedy choices</strong>: - If a triplet is valid and has the required value for one of the coordinates, we “take” it. - We do not need to backtrack or search combinations. - As long as we collect the three necessary components, merging them gives the target.</p>
<p>This approach is optimal and efficient because each choice is independent and bounded by the target.</p>
</section>
</section>
<section id="source-code" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Source code</h1>
<div class="sourceCode" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> typing <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> List</span>
<span id="cb8-2"></span>
<span id="cb8-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Solution:</span>
<span id="cb8-4">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> mergeTriplets(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, triplets: List[List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>]], target: List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">bool</span>:</span>
<span id="cb8-5">        a, b, c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># will simulate the merged triplet</span></span>
<span id="cb8-6"></span>
<span id="cb8-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> triplet <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> triplets:</span>
<span id="cb8-8">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Only consider triplets where all elements are &lt;= target</span></span>
<span id="cb8-9">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> target[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> target[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> target[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>]:</span>
<span id="cb8-10">                a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(a, triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>])</span>
<span id="cb8-11">                b <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(b, triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>])</span>
<span id="cb8-12">                c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(c, triplet[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>])</span>
<span id="cb8-13"></span>
<span id="cb8-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> [a, b, c] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> target</span></code></pre></div>


</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-triplet/</guid>
  <pubDate>Sat, 19 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Merge Triplets to Form Target Triplet</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/project-euler-52/</link>
  <description><![CDATA[ 




<p>
It can be seen that the number, <img src="https://latex.codecogs.com/png.latex?125874">, and its double, <img src="https://latex.codecogs.com/png.latex?251748">, contain exactly the same digits, but in a different order.
</p>
<p>
Find the smallest positive integer, <img src="https://latex.codecogs.com/png.latex?x">, such that <img src="https://latex.codecogs.com/png.latex?2x">, <img src="https://latex.codecogs.com/png.latex?3x">, <img src="https://latex.codecogs.com/png.latex?4x">, <img src="https://latex.codecogs.com/png.latex?5x">, and <img src="https://latex.codecogs.com/png.latex?6x">, contain the same digits.
</p>
<section id="brute-force-idea-on2-or-worse" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Brute Force Idea (<img src="https://latex.codecogs.com/png.latex?O(n%5E2)"> or worse)</h1>
<p>Test each number <code>x</code> starting from 1, and check if <code>2x, ..., 6x</code> are permutations of <code>x</code>. While that works, it’s not efficient if we don’t restrict the search space.</p>
</section>
<section id="key-observations-to-reduce-the-search-space" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Key observations (To Reduce the Search Space)</h1>
<section id="same-number-of-digits" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="same-number-of-digits"><span class="header-section-number">2.1</span> Same number of digits:</h2>
<p>If <code>x</code> has <code>d</code> digits, <code>6x</code> must not have more digits than <code>x</code>, or they can’t be permutations.</p>
<p>So</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(x) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">6</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">x</span>)</span></code></pre></div>
<p>Example: If <code>x = 100</code>, then <code>6x = 600</code>, same digit count (3). But <code>x = 200</code>, then <code>6x = 1200</code> (4 digits), not possible.</p>
<p>That gives <strong>a range to search in</strong>:</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> x <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">**</span>(d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">**</span>d):</span>
<span id="cb2-2">    ...</span></code></pre></div>
</section>
<section id="digit-permutation-check" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="digit-permutation-check"><span class="header-section-number">2.2</span> Digit permutation check:</h2>
<p>Instead of sorting each time (<img src="https://latex.codecogs.com/png.latex?O(n%5Clog%20n)">), use:</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> canonical(n):</span>
<span id="cb3-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">''</span>.join(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sorted</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">str</span>(n)))</span></code></pre></div>
<p>then</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1">c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> canonical(x)</span>
<span id="cb4-2"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">all</span>(c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> canonical(i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> x) <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>))</span></code></pre></div>
<p>This function is creating a canonical (standardized) form of any number:</p>
<ul>
<li><p><code>str(n)</code> converts the number to a string (e.g., <code>123</code> → <code>'123'</code>)</p></li>
<li><p><code>sorted(...)</code> puts the digits in ascending order (e.g., <code>'321'</code> → <code>['1','2','3']</code>)</p></li>
<li><p><code>''.join(...)</code> joins them back to a single string (e.g., <code>['1','2','3']</code> → <code>'123'</code>)</p></li>
</ul>
<p>So:</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1">canonical(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">123</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'123'</span></span>
<span id="cb5-2">canonical(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">231</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'123'</span></span>
<span id="cb5-3">canonical(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">312</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'123'</span></span></code></pre></div>
<p>All are permutations of the same digits ⇒ same canonical form</p>
<p>Time Complexity</p>
<ul>
<li><p>Each check is ~O(1) due to short digit lengths</p></li>
<li><p>The loop is linear in x (but bounded by 6-digit numbers)</p></li>
<li><p>Much faster than O(n²) since the search space is tightly controlled</p></li>
</ul>
<div id="fa45b65c" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> canonical(n):</span>
<span id="cb6-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">''</span>.join(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sorted</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">str</span>(n)))</span>
<span id="cb6-3"></span>
<span id="cb6-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> has_same_digits(x):</span>
<span id="cb6-5">    c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> canonical(x)</span>
<span id="cb6-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">all</span>(canonical(x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> i) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> c <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>))</span>
<span id="cb6-7"></span>
<span id="cb6-8"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> find_smallest_permuted_multiple():</span>
<span id="cb6-9">    x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100000</span></span>
<span id="cb6-10">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">while</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>:</span>
<span id="cb6-11">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> has_same_digits(x):</span>
<span id="cb6-12">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> x</span>
<span id="cb6-13">        x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb6-14"></span>
<span id="cb6-15"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(find_smallest_permuted_multiple())  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Output: 142857</span></span></code></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>142857</code></pre>
</div>
</div>


</section>
</section>

 ]]></description>
  <category>project-euler</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/project-euler-52/</guid>
  <pubDate>Sat, 19 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Valid Parenthesis String with Wildcards - A Greedy Stack Approach</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-678-valid-parenthesis-string/</link>
  <description><![CDATA[ 




<section id="intuition" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Intuition</h1>
<p>When reading the problem description of LeetCode 678 – <em>Valid Parenthesis String</em>, I immediately thought of the classic balanced parentheses problem. However, the wildcard character <code>*</code>, which can be treated as <code>'('</code>, <code>')'</code>, or an empty string, makes it more complex.</p>
<p>My first instinct was to <strong>simulate a stack</strong> like how we handle simple parenthesis matching: - Push <code>'('</code> onto the stack. - Pop for every <code>')'</code>. - But now, we need to consider <code>'*'</code> flexibly. This led me to a <strong>one-stack idea</strong>, which failed because we need to preserve the order of matching.</p>
<p>That realization pushed me to a <strong>two-stack greedy strategy</strong>: - One stack for <code>'('</code> indices. - One for <code>'*'</code> indices. Then try to match the remaining <code>'('</code> with any <code>'*'</code> that appears after it.</p>
</section>
<section id="approach" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Approach</h1>
<p>We simulate the process using two stacks: - <code>stack_paren</code>: holds indices of <code>'('</code>. - <code>stack_star</code>: holds indices of <code>'*'</code>.</p>
<p>As we iterate: - Push index into <code>stack_paren</code> for <code>'('</code>. - Push index into <code>stack_star</code> for <code>'*'</code>. - For <code>')'</code>, try to pop from <code>stack_paren</code> first (prefer real ‘(’), else from <code>stack_star</code>.</p>
<p>Finally, for any unmatched <code>'('</code> left, we try to pair with <code>'*'</code> that occur <strong>after</strong> it. If a <code>'('</code> appears after any available <code>'*'</code>, it’s invalid.</p>
</section>
<section id="code" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Code</h1>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Solution:</span>
<span id="cb1-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> checkValidString(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, s: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">str</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">bool</span>:</span>
<span id="cb1-3">        stack_paren <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># stores indices of '('</span></span>
<span id="cb1-4">        stack_star <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># stores indices of '*'</span></span>
<span id="cb1-5"></span>
<span id="cb1-6">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, c <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(s):</span>
<span id="cb1-7">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'('</span>:</span>
<span id="cb1-8">                stack_paren.append(i)</span>
<span id="cb1-9">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'*'</span>:</span>
<span id="cb1-10">                stack_star.append(i)</span>
<span id="cb1-11">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">')'</span>:</span>
<span id="cb1-12">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> stack_paren:</span>
<span id="cb1-13">                    stack_paren.pop()</span>
<span id="cb1-14">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> stack_star:</span>
<span id="cb1-15">                    stack_star.pop()</span>
<span id="cb1-16">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb1-17">                    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span></span>
<span id="cb1-18"></span>
<span id="cb1-19">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Match remaining '(' with '*' appearing after it</span></span>
<span id="cb1-20">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">while</span> stack_paren <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> stack_star:</span>
<span id="cb1-21">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> stack_paren[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> stack_star[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]:</span>
<span id="cb1-22">                stack_paren.pop()</span>
<span id="cb1-23">                stack_star.pop()</span>
<span id="cb1-24">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb1-25">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span></span>
<span id="cb1-26"></span>
<span id="cb1-27">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">not</span> stack_paren</span></code></pre></div>
<section id="complexity" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="complexity"><span class="header-section-number">3.1</span> Complexity</h2>
<ul>
<li><p>Time complexity: O(n) We traverse the string once and at most once more to match remaining parentheses.</p></li>
<li><p>Space complexity: O(n) In the worst case, both stacks could hold all characters.</p></li>
</ul>
</section>
</section>
<section id="thought-process-dynamic-programming-approach" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Thought Process: Dynamic Programming Approach</h1>
<p>Initially, before settling on the greedy stack method, we considered a <strong>dynamic programming (DP)</strong> solution.</p>
<p>The idea was to define a 2D DP table:</p>
<ul>
<li>Let <code>dp[i][j]</code> be <code>True</code> if the substring <code>s[i][j]</code> can be a valid parenthesis string.</li>
</ul>
<p>This definition supports checking subintervals, including the role of <code>*</code>. Since <code>*</code> can represent <code>'('</code>, <code>')'</code>, or <code>''</code>, we need to explore all possibilities recursively or fill them iteratively.</p>
<section id="base-cases" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="base-cases"><span class="header-section-number">4.1</span> Base Cases</h2>
<ul>
<li><p>Every <code>dp[i][i]</code> is <code>True</code> if <code>s[i] == '*'</code>, because <code>'*'</code> can represent an empty string.</p></li>
<li><p>For length 2 substrings:</p>
<ul>
<li>Valid cases include <code>()</code>, <code>(*)</code>, <code>(*</code>, <code>*)</code>, and <code>**</code>.</li>
</ul></li>
</ul>
</section>
<section id="transition" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="transition"><span class="header-section-number">4.2</span> Transition</h2>
<p>To compute <code>dp[i][j]</code>, we iterate over all <code>k</code> such that <code>i &lt; k ≤ j</code>, and check:</p>
<ul>
<li>If <code>s[i] == '(' or '*'</code> <strong>and</strong> <code>s[k] == ')' or '*'</code><br>
<strong>and</strong> <code>dp[i+1][k-1] == True</code> (i.e., the inner substring is valid)<br>
<strong>and</strong> <code>dp[k+1][j] == True</code> (i.e., the remaining part is also valid)</li>
</ul>
<p>Then <code>dp[i][j] = True</code>.</p>
<p>This leads to an <strong>O(n³)</strong> time complexity in the worst case due to 3 nested loops: - <code>i</code> from <code>n-1</code> to <code>0</code> - <code>j</code> from <code>i</code> to <code>n-1</code> - <code>k</code> from <code>i+1</code> to <code>j</code></p>
<p>We may reduce to <strong>O(n²)</strong> using memoization and early stopping, but this still isn’t optimal for large <code>n</code>.</p>
</section>
<section id="why-we-switched-to-stack" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="why-we-switched-to-stack"><span class="header-section-number">4.3</span> Why We Switched to Stack</h2>
<p>While the DP approach gives a rigorous solution, the memory and runtime costs are high for <code>n = 100</code>. This motivated us to find a <strong>greedy method</strong> — leading to the efficient two-stack approach which runs in linear time and works within the problem’s constraints.</p>
</section>
<section id="code-1" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="code-1"><span class="header-section-number">4.4</span> Code</h2>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Solution:</span>
<span id="cb2-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> checkValidString(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, s: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">str</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">bool</span>:</span>
<span id="cb2-3">        n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(s)</span>
<span id="cb2-4">        dp <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [[<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> n <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> _ <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n)]</span>
<span id="cb2-5"></span>
<span id="cb2-6">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Base cases: single character</span></span>
<span id="cb2-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n):</span>
<span id="cb2-8">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> s[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'*'</span>:</span>
<span id="cb2-9">                dp[i][i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span></span>
<span id="cb2-10"></span>
<span id="cb2-11">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Base cases: two characters</span></span>
<span id="cb2-12">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):</span>
<span id="cb2-13">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> (s[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'('</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">or</span> s[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'*'</span>) <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> (s[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">')'</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">or</span> s[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'*'</span>):</span>
<span id="cb2-14">                dp[i][i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span></span>
<span id="cb2-15"></span>
<span id="cb2-16">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Fill DP table</span></span>
<span id="cb2-17">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> size <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, n):</span>
<span id="cb2-18">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> size):</span>
<span id="cb2-19">                j <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> size</span>
<span id="cb2-20">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> s[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'*'</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> dp[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>][j]:</span>
<span id="cb2-21">                    dp[i][j] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span></span>
<span id="cb2-22">                    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">continue</span></span>
<span id="cb2-23">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> k <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, j<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):</span>
<span id="cb2-24">                    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> (s[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'('</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">or</span> s[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'*'</span>) <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> (s[k] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">')'</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">or</span> s[k] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'*'</span>):</span>
<span id="cb2-25">                        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> (k <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">or</span> dp[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>][k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]) <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> (k <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> j <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">or</span> dp[k<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>][j]):</span>
<span id="cb2-26">                            dp[i][j] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span></span>
<span id="cb2-27">                            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">break</span></span>
<span id="cb2-28"></span>
<span id="cb2-29">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> dp[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>][n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]</span></code></pre></div>
</section>
</section>
<section id="takeaway" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Takeaway</h1>
<p>What seemed like a brute-force DP problem can actually be solved efficiently with a greedy strategy. The key was realizing that ’*’ can help balance ‘(’ only if it appears after ‘(’. Thinking step-by-step and simulating the process helped me discover this clean and optimal solution.</p>
<section id="why-the-two-stack-approach-is-greedy" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="why-the-two-stack-approach-is-greedy"><span class="header-section-number">5.1</span> Why the Two-Stack Approach Is Greedy</h2>
<p>We call the <strong>two-stack approach</strong> to Leetcode 678 a <strong>greedy algorithm</strong> because it makes <strong>locally optimal decisions</strong> at each step, aiming to resolve mismatches immediately without exploring all possibilities.</p>
<section id="immediate-matching" class="level3" data-number="5.1.1">
<h3 data-number="5.1.1" class="anchored" data-anchor-id="immediate-matching"><span class="header-section-number">5.1.1</span> Immediate Matching</h3>
<ul>
<li>When encountering a <code>')'</code>, we:
<ul>
<li>First try to match it with a <code>'('</code> (if available),</li>
<li>If not, try to match it with a <code>'*'</code> (interpreted as <code>'('</code>).</li>
</ul></li>
<li>If neither is available, return <code>False</code> immediately.</li>
</ul>
<blockquote class="blockquote">
<p>This is a greedy decision: match now rather than wait for a possibly better match later.</p>
</blockquote>
</section>
<section id="post-processing-for" class="level3" data-number="5.1.2">
<h3 data-number="5.1.2" class="anchored" data-anchor-id="post-processing-for"><span class="header-section-number">5.1.2</span> Post-Processing for <code>'('</code></h3>
<ul>
<li>After scanning the string, some <code>'('</code> may remain.</li>
<li>We greedily match each <code>'('</code> with a later <code>'*'</code> (interpreted as <code>')'</code>).</li>
<li>This match must happen in order: <code>'('</code> must appear <strong>before</strong> <code>'*'</code>.</li>
</ul>
</section>
<section id="no-backtracking-or-multiple-scenarios" class="level3" data-number="5.1.3">
<h3 data-number="5.1.3" class="anchored" data-anchor-id="no-backtracking-or-multiple-scenarios"><span class="header-section-number">5.1.3</span> No Backtracking or Multiple Scenarios</h3>
<ul>
<li>The algorithm never revisits decisions.</li>
<li>Unlike dynamic programming (which explores all valid ways to interpret <code>'*'</code>), the greedy approach only considers matches that help <strong>balance the parentheses immediately</strong>.</li>
</ul>
</section>
<section id="summary-table" class="level3" data-number="5.1.4">
<h3 data-number="5.1.4" class="anchored" data-anchor-id="summary-table"><span class="header-section-number">5.1.4</span> Summary Table</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Character</th>
<th>Greedy Behavior</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>')'</code></td>
<td>Match immediately with <code>'('</code> or <code>'*'</code></td>
</tr>
<tr class="even">
<td><code>'('</code></td>
<td>Saved in stack for future match</td>
</tr>
<tr class="odd">
<td><code>'*'</code></td>
<td>Stored to match later as <code>'('</code> or <code>')'</code></td>
</tr>
<tr class="even">
<td>Remaining <code>'('</code></td>
<td>Matched with later <code>'*'</code> greedily</td>
</tr>
</tbody>
</table>
</section>
<section id="why-greedy-works-here" class="level3" data-number="5.1.5">
<h3 data-number="5.1.5" class="anchored" data-anchor-id="why-greedy-works-here"><span class="header-section-number">5.1.5</span> Why Greedy Works Here</h3>
<p>This problem permits multiple interpretations of <code>'*'</code>, but the greedy strategy works because: - We never allow unmatched <code>')'</code>. - Every <code>'('</code> must eventually be matched, and greedy ensures we try the best-case option first.</p>
<blockquote class="blockquote">
<p>Greedy is valid in this problem due to the constraints and structure of balanced parentheses.</p>
</blockquote>


</section>
</section>
</section>

 ]]></description>
  <category>project-euler</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-678-valid-parenthesis-string/</guid>
  <pubDate>Sat, 19 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Optimizing String Partitioning – LeetCode 763 Deep Dive</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-/</link>
  <description><![CDATA[ 




<section id="intuition" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Intuition</h1>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>We are given a string <code>s</code>, and we need to partition it into as many parts as possible such that <strong>each letter appears in at most one part</strong>. This suggests a <strong>greedy approach</strong>, where we keep extending the current partition until we are sure no character in it appears later.</p>
<p>Initially, I thought of tracking how many times each character appears and using that to decide when a character is “done” — this forms <strong>Approach 1</strong>.</p>
<p>Later, I realized that we can optimize by <strong>just tracking the last occurrence</strong> of each character and extending the partition greedily — this is <strong>Approach 2</strong>.</p>
</section>
<section id="approach" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Approach</h1>
<!-- Describe your approach to solving the problem. -->
<section id="approach-1-frequency-based-tracking-counter" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="approach-1-frequency-based-tracking-counter"><span class="header-section-number">2.1</span> Approach 1: Frequency-based Tracking (Counter)</h2>
<ol type="1">
<li><p>Use <code>Counter</code> to store total character frequency.</p></li>
<li><p>As we iterate through <code>s</code>, maintain a <code>current_count</code> Counter.</p></li>
<li><p>Whenever all counts in <code>current_count</code> match the ones in <code>total_count</code>, we can safely cut the partition.</p></li>
</ol>
</section>
<section id="approach-2-greedy-with-last-occurrence" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="approach-2-greedy-with-last-occurrence"><span class="header-section-number">2.2</span> Approach 2: Greedy with Last Occurrence</h2>
<ol type="1">
<li><p>Precompute a map of the <strong>last index</strong> of every character.</p></li>
<li><p>While iterating, keep track of the current partition’s end by updating to the farthest last index seen so far.</p></li>
<li><p>When the current index equals the <code>end</code>, it means all characters in this partition are safely enclosed — we can cut here.</p></li>
</ol>
</section>
</section>
<section id="complexity" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Complexity</h1>
<section id="approach-1" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="approach-1"><span class="header-section-number">3.1</span> Approach 1</h2>
<ul>
<li>Time complexity: <img src="https://latex.codecogs.com/png.latex?O(n%5Ccdot%20a)"> where <img src="https://latex.codecogs.com/png.latex?a"> is the number of unique characters (&lt;= 26)</li>
<li>Space complexity: <img src="https://latex.codecogs.com/png.latex?O(a)"> for <code>Counter</code></li>
</ul>
</section>
<section id="approach-2" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="approach-2"><span class="header-section-number">3.2</span> Approach 2</h2>
<ul>
<li>Time complexity: <img src="https://latex.codecogs.com/png.latex?O(n)"></li>
<li>Space complexity: <img src="https://latex.codecogs.com/png.latex?O(a)"></li>
</ul>
</section>
</section>
<section id="code" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Code</h1>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Solution:</span>
<span id="cb1-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> partitionLabels(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, s: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">str</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>]:</span>
<span id="cb1-3">        </span>
<span id="cb1-4">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># get a string</span></span>
<span id="cb1-5"></span>
<span id="cb1-6">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># part -&gt; as many parts as possible</span></span>
<span id="cb1-7">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1 letter appears in at most 1 part.</span></span>
<span id="cb1-8"></span>
<span id="cb1-9">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># return the list of size of these parts</span></span>
<span id="cb1-10">        </span>
<span id="cb1-11">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># as many parts as possible </span></span>
<span id="cb1-12">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># -&gt; parts is as shorts as possible</span></span>
<span id="cb1-13"></span>
<span id="cb1-14">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># if we find a char, we want to find the lastest char for cut into a part</span></span>
<span id="cb1-15"></span>
<span id="cb1-16">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># if we have a count_chars array, </span></span>
<span id="cb1-17">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># we can use that for end find char</span></span>
<span id="cb1-18"></span>
<span id="cb1-19">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#################</span></span>
<span id="cb1-20"></span>
<span id="cb1-21">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # import counter class from collections module</span></span>
<span id="cb1-22">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># from collections import Counter</span></span>
<span id="cb1-23"></span>
<span id="cb1-24">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># total_count = Counter(s)</span></span>
<span id="cb1-25"></span>
<span id="cb1-26">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ans = []</span></span>
<span id="cb1-27">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># current_count = Counter()</span></span>
<span id="cb1-28">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># start = 0</span></span>
<span id="cb1-29">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># for i, char in enumerate(s):</span></span>
<span id="cb1-30">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#     current_count[char] += 1</span></span>
<span id="cb1-31">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#     # check all char in part == that char in count_part -&gt; cut it</span></span>
<span id="cb1-32"></span>
<span id="cb1-33">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#     if all(current_count[c] == total_count[c] for c in current_count):</span></span>
<span id="cb1-34">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#         ans.append(i - start + 1)</span></span>
<span id="cb1-35">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#         start = i + 1</span></span>
<span id="cb1-36">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#         current_count.clear()</span></span>
<span id="cb1-37">        </span>
<span id="cb1-38">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># return ans</span></span>
<span id="cb1-39"></span>
<span id="cb1-40">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">################################</span></span>
<span id="cb1-41">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Ok</span></span>
<span id="cb1-42"></span>
<span id="cb1-43">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># but instead of store all char in current part, and recheck it (O(n^2))</span></span>
<span id="cb1-44">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># we just really concern about the last index of out current char</span></span>
<span id="cb1-45">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># (if we get char[a], we want to expand to the last index of [a])</span></span>
<span id="cb1-46">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># on the track of that, we can get new char,</span></span>
<span id="cb1-47">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># if that char have the last index &gt; 'a'.</span></span>
<span id="cb1-48">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># we need to update that</span></span>
<span id="cb1-49"></span>
<span id="cb1-50">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># TC: O(n)</span></span>
<span id="cb1-51"></span>
<span id="cb1-52">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Step 1: Record the last occurence of each character</span></span>
<span id="cb1-53">        last_index <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {char: i <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, char <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(s)}</span>
<span id="cb1-54"></span>
<span id="cb1-55">        result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb1-56">        start <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb1-57">        end <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb1-58"></span>
<span id="cb1-59">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Step 2: Iterate and find partition points</span></span>
<span id="cb1-60">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, char <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(s):</span>
<span id="cb1-61">            end <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(end, last_index[char]) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># extend the partition to the last seen char</span></span>
<span id="cb1-62">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> end:</span>
<span id="cb1-63">                result.append(end <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> start <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># cut here</span></span>
<span id="cb1-64">                start <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># new partition</span></span>
<span id="cb1-65">        </span>
<span id="cb1-66">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> result</span></code></pre></div>


</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <category>greedy</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-/</guid>
  <pubDate>Sat, 19 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>846. Hand of straights</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-hand-of-straights/</link>
  <description><![CDATA[ 




<section id="question" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Question</h1>
<p>Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.</p>
<p>Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.</p>
<p>Example 1:</p>
<p>Input: <code>hand = [1,2,3,6,2,3,4,7,8], groupSize = 3</code></p>
<p>Output: <code>true</code></p>
<p>Explanation: <code>Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]</code></p>
<p>Example 2:</p>
<p>Input: <code>hand = [1,2,3,4,5], groupSize = 4</code></p>
<p>Output: <code>false</code></p>
<p>Explanation: <code>Alice's hand can not be rearranged into groups of 4.</code></p>
<p>Constraints:</p>
<ul>
<li><code>1 &lt;= hand.length &lt;= 104</code></li>
<li><code>0 &lt;= hand[i] &lt;= 109</code></li>
<li><code>1 &lt;= groupSize &lt;= hand.length</code></li>
</ul>
</section>
<section id="intuition" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Intuition</h1>
<p>The goal is to divide the list of cards (hand) into groups of groupSize, where each group consists of <code>consecutive numbers</code>.</p>
<p>A natural real-world analogy is playing cards — when we try to group our cards into sequences, we often:</p>
<ul>
<li>Start from the <code>smallest card</code>,</li>
<li>Try to build a group of <code>groupSize</code> consecutive cards, like <code>[x, x+1, x+2, ...]</code>. So, the greedy strategy is:</li>
</ul>
<ol type="1">
<li>Count the frequency of each card using <code>collections.Counter</code>.</li>
<li>Sort the keys (or use a min-heap for efficient access to the smallest card).</li>
<li>For each smallest available card, attempt to form a group starting from that card.</li>
<li>For each card in the group, <strong>decrement its count</strong>.</li>
</ol>
<ul>
<li>If any required card is missing or exhausted, return <code>False</code>.</li>
</ul>
<p>If all cards can be grouped successfully, return <code>True</code>.</p>
</section>
<section id="approach" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Approach</h1>
<section id="understand-the-problem-by-simulation" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="understand-the-problem-by-simulation"><span class="header-section-number">3.1</span> Understand the Problem by Simulation</h2>
<p>Try simulating small examples manually:</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1">hand <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">6</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span>], groupSize <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span></span></code></pre></div>
<p>Try to group them:</p>
<ul>
<li>Group 1: [1,2,3]</li>
<li>Group 2: [2,3,4]</li>
<li>Group 3: [6,7,8]</li>
</ul>
<p>We realize:</p>
<ul>
<li>We always start from the <strong>smallest number available</strong></li>
<li>We try to form a <strong>consecutive group</strong> from that number</li>
<li>We must <strong>consume one of each</strong> in the sequence <code>[x, x+1, ..., x+groupSize-1]</code></li>
</ul>
</section>
<section id="greedy-choice-property" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="greedy-choice-property"><span class="header-section-number">3.2</span> Greedy Choice Property</h2>
<p>Ask: “At each step, what is the best immediate move?”</p>
<p>Answer:</p>
<p>Always form a group starting from the <strong>smallest card available</strong>, because delaying it may block forming valid groups later.</p>
<p>That’s greedy - always take the <strong>smallest ungrouped card</strong> and try to complete a group from it.</p>
</section>
<section id="track-resources" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="track-resources"><span class="header-section-number">3.3</span> Track Resources</h2>
<p>We need:</p>
<ul>
<li>A count of how many times each card appears -&gt; use <code>Counter</code></li>
<li>Efficient access to the smallest available card -&gt; use <code>Min-heap</code></li>
</ul>
</section>
<section id="prove-it-locally" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="prove-it-locally"><span class="header-section-number">3.4</span> Prove it Locally</h2>
<p>Try:</p>
<ul>
<li>Can I always remove <code>groupSize</code> consecutive numbers?</li>
<li>If not, can I return early?</li>
</ul>
<p>We try to decrement counts and remove from the heap only when count becomes <code>0</code> to keep it consistent.</p>
</section>
<section id="edge-case-check" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="edge-case-check"><span class="header-section-number">3.5</span> Edge Case Check</h2>
<p>Think:</p>
<ul>
<li>If one card has more copies than others, can it still be grouped?</li>
<li>What if the total number of cards isn’t divisible</li>
</ul>
<p>Handle these early:</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(hand) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> groupSize <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>: <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span></span></code></pre></div>
</section>
</section>
<section id="visualization" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Visualization</h1>
<div class="quarto-video"><video id="video_shortcode_videojs_video1" class="video-js vjs-default-skin vjs-fluid" controls="" preload="auto" data-setup="{}" title=""><source src="videos/IsNStraightHandTrueLogic.mp4"></video></div>
</section>
<section id="complexity" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Complexity</h1>
<section id="time-complexity" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="time-complexity"><span class="header-section-number">5.1</span> Time Complexity</h2>
<p>Let:</p>
<ul>
<li><code>n = len(hand)</code> (total number of cards)</li>
<li><code>k = number of unique cards in hand</code></li>
</ul>
<p>Breakdown:</p>
<ul>
<li>Building the frequency map: <code>O(n)</code></li>
<li>Sorting keys or using a heap: <code>O(k log k)</code></li>
<li>For each unique card, in worst case, we might scan up to <code>groupSize</code> consecutive numbers → total time in worst case: <code>O(n log k + n × groupSize)</code> But since the number of total operations across all groups is bounded by n (each card is used once), we simplify:</li>
</ul>
<p>Total Time Complexity: <code>O(n log k)</code></p>
<p>(If we use a heap, the log factor applies to the number of unique cards.)</p>
</section>
<section id="space-complexity" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="space-complexity"><span class="header-section-number">5.2</span> Space Complexity</h2>
<p><code>Counter</code>: stores up to <code>k</code> keys → <code>O(k)</code></p>
<p>Optionally a heap: <code>O(k)</code></p>
<p>No recursion or extra structures</p>
<p>Total Space Complexity: <code>O(k)</code></p>
</section>
</section>
<section id="code" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Code</h1>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> typing <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> List</span>
<span id="cb3-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> collections <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Counter</span>
<span id="cb3-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> heapq</span>
<span id="cb3-4"></span>
<span id="cb3-5"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Solution:</span>
<span id="cb3-6">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> isNStraightHand(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, hand: List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>], groupSize: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">bool</span>:</span>
<span id="cb3-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(hand) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> groupSize <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb3-8">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span></span>
<span id="cb3-9"></span>
<span id="cb3-10">        count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Counter(hand)</span>
<span id="cb3-11">        min_heap <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">list</span>(count.keys())</span>
<span id="cb3-12">        heapq.heapify(min_heap)</span>
<span id="cb3-13"></span>
<span id="cb3-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">while</span> min_heap:</span>
<span id="cb3-15">            first <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> min_heap[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb3-16">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(groupSize):</span>
<span id="cb3-17">                current <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> first <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> i</span>
<span id="cb3-18">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> count[current] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb3-19">                    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span></span>
<span id="cb3-20">                count[current] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb3-21">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> count[current] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb3-22">                    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> min_heap[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]:</span>
<span id="cb3-23">                        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span></span>
<span id="cb3-24">                    heapq.heappop(min_heap)</span>
<span id="cb3-25">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span></span></code></pre></div>


</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-hand-of-straights/</guid>
  <pubDate>Fri, 18 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Greedy Problem Solving Framework</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/greedy/</link>
  <description><![CDATA[ 




<section id="greedy-problem-solving-framework" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Greedy Problem Solving Framework</h1>
<p>Greedy algorithms solve problems by <strong>making locally optimal choices</strong> at each step in the hope that they lead to a <strong>globally optimal solution</strong> without backtracking. However, <strong>not all problems can be solved greedily</strong>. Here’s a reliable framework to decide <strong>when and how to apply</strong> a greedy strategy.</p>
<hr>
<section id="problem-understanding" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="problem-understanding"><span class="header-section-number">1.1</span> Problem Understanding</h2>
<ul>
<li><strong>Goal</strong>: What is being optimized? (e.g., minimize cost, maximize profit)</li>
<li><strong>Constraints</strong>: Do choices need to be irreversible or done in order?</li>
<li><strong>Input Size</strong>: Is brute-force even feasible?</li>
</ul>
<hr>
</section>
<section id="brute-force-first" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="brute-force-first"><span class="header-section-number">1.2</span> Brute Force First</h2>
<ul>
<li>Try all possible paths/choices.</li>
<li>Ask: Why is this inefficient?</li>
<li>This helps reveal <em>structure</em> in the problem (e.g., repeated states, redundant decisions).</li>
</ul>
<hr>
</section>
<section id="identify-the-greedy-choice" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="identify-the-greedy-choice"><span class="header-section-number">1.3</span> Identify the “Greedy Choice”</h2>
<p>Ask: - What is the <em>best local decision</em> I can make at each step? - Can I prove that making this choice will <em>never hurt future decisions</em>?</p>
<p>Common greedy choices: - <strong>Max gain</strong> per step - <strong>Min cost</strong> to reach the next step - <strong>Earliest deadline</strong>, <strong>highest value per weight</strong>, etc.</p>
<hr>
</section>
<section id="validate-greedy-is-safe" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="validate-greedy-is-safe"><span class="header-section-number">1.4</span> Validate Greedy is Safe</h2>
<p>Test your greedy choice with: - <strong>Counterexamples</strong>: Try inputs where greedy may fail. - <strong>Proof</strong>: Can you prove “greedy choice” leads to an optimal solution?</p>
<p>Techniques: - <strong>Exchange Argument</strong> - <strong>Greedy Stays Ahead</strong></p>
<hr>
</section>
<section id="implement-test" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="implement-test"><span class="header-section-number">1.5</span> Implement &amp; Test</h2>
<ul>
<li>Use <code>O(n)</code> or <code>O(n log n)</code> greedy logic.</li>
<li>Track accumulative values (e.g., balance, remaining capacity).</li>
<li>Reset conditions if necessary (like in gas station).</li>
</ul>
<hr>
</section>
<section id="common-greedy-patterns" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="common-greedy-patterns"><span class="header-section-number">1.6</span> Common Greedy Patterns</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>Pattern</th>
<th>Example Problems</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Interval Scheduling</td>
<td>Activity selection, meeting rooms</td>
</tr>
<tr class="even">
<td>Resource Allocation</td>
<td>Fractional knapsack</td>
</tr>
<tr class="odd">
<td>Accumulated Constraints</td>
<td>Gas Station, Jump Game</td>
</tr>
<tr class="even">
<td>Covering Problems</td>
<td>Set cover approximations</td>
</tr>
</tbody>
</table>
<hr>
</section>
<section id="mindset-summary" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="mindset-summary"><span class="header-section-number">1.7</span> Mindset Summary</h2>
<blockquote class="blockquote">
<p>“Make the best local decision… but <strong>prove</strong> or <strong>observe</strong> that it’s globally optimal.”</p>
</blockquote>
<p>Use greedy when: - Future choices don’t depend heavily on past ones - Local optimum leads to global optimum - Problem can be modeled with <strong>monotonic constraints</strong></p>
<hr>
<p><strong>Example</strong>: In the gas station problem<br>
- Greedy resets starting index when <code>curr_tank &lt; 0</code><br>
- If <code>total_tank &gt;= 0</code>, a valid start must exist<br>
- Greedy eliminates bad candidates efficiently</p>
<hr>
<p>Final Note:<br>
Not all problems are greedy-solvable. When in doubt, try: - Dynamic Programming - Backtracking with pruning</p>


</section>
</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/greedy/</guid>
  <pubDate>Thu, 17 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Gas Station</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-gas-station/</link>
  <description><![CDATA[ 




<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Imagine you’re on a circular road trip with your car, visiting a series of gas stations. Each station provides a certain amount of gas, but it also costs you gas to drive to the next one. The question is: <strong>Can you complete the entire loop starting at one of the stations, without ever running out of fuel?</strong></p>
<p>This is the essence of the <strong>Gas Station Problem</strong>, a well-known greedy algorithm question that tests your ability to reason about cumulative gains and losses over a circular path.</p>
<p>At first glance, this might seem like a brute-force problem—try every station as a starting point, simulate the journey, and check which one works. But with some smart observations, we can reduce the solution from <strong>O(n²)</strong> to <strong>O(n)</strong> using a <strong>greedy strategy</strong>.</p>
<p>In this post, we’ll guide you step-by-step: - From a <strong>naive brute-force solution</strong>, - To discovering key <strong>mathematical observations</strong>, and - Finally building an <strong>efficient greedy algorithm</strong> with a visual explanation.</p>
<p>Whether you’re preparing for coding interviews, learning algorithms, or building animations with Manim, this deep dive will help you not only solve the problem but also <strong>understand the “why” behind the solution</strong>.</p>
</section>
<section id="problem-statement" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 🔍 Problem Statement</h1>
<p>You are given two integer arrays:</p>
<ul>
<li><code>gas[i]</code>: the amount of fuel available at station <code>i</code></li>
<li><code>cost[i]</code>: the amount of fuel it takes to travel from station <code>i</code> to station <code>(i + 1) % n</code></li>
</ul>
<p>Your task is to determine the <strong>starting gas station index</strong> from which you can travel around the circuit once in the clockwise direction <strong>without ever running out of gas</strong>. If it’s not possible, return <code>-1</code>.</p>
<section id="example" class="level3" data-number="2.0.1">
<h3 data-number="2.0.1" class="anchored" data-anchor-id="example"><span class="header-section-number">2.0.1</span> Example</h3>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1">gas  <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>]</span>
<span id="cb1-2">cost <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>]</span></code></pre></div>
</section>
<section id="contraints" class="level3" data-number="2.0.2">
<h3 data-number="2.0.2" class="anchored" data-anchor-id="contraints"><span class="header-section-number">2.0.2</span> Contraints</h3>
<ul>
<li>The journey is <strong>circular</strong>, meaning after the last station, you return to the first.</li>
<li>You must start at a station and can only travel clockwise.</li>
<li>You must always have <strong>non-negative fuel</strong> in your tank.</li>
</ul>
</section>
</section>
<section id="naive-brute-force-approach" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Naive Brute-Force Approach</h1>
<p>Before diving into optimization, let’s understand the <strong>simplest possible way</strong> to solve the problem.</p>
<section id="brute-force-logic" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="brute-force-logic"><span class="header-section-number">3.1</span> Brute-Force Logic</h2>
<p>Try starting at <strong>every station one by one</strong>, and simulate the full circular trip:</p>
<ol type="1">
<li>Initialize your fuel tank to 0.</li>
<li>At each step, add <code>gas[i]</code> to your tank and subtract <code>cost[i]</code>.</li>
<li>If at any point the tank drops below zero, the trip fails from this starting point.</li>
<li>Repeat for all <code>n</code> starting points.</li>
</ol>
<section id="example-code" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="example-code"><span class="header-section-number">3.1.1</span> Example Code</h3>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> can_complete_circuit_brute(gas, cost):</span>
<span id="cb2-2">    n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(gas)</span>
<span id="cb2-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> start <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n):</span>
<span id="cb2-4">        tank <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb2-5">        completed <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span></span>
<span id="cb2-6">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n):</span>
<span id="cb2-7">            idx <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (start <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> i) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> n</span>
<span id="cb2-8">            tank <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> gas[idx] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> cost[idx]</span>
<span id="cb2-9">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> tank <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb2-10">                completed <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span></span>
<span id="cb2-11">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">break</span></span>
<span id="cb2-12">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> completed:</span>
<span id="cb2-13">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> start</span>
<span id="cb2-14">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span></code></pre></div>
</section>
</section>
<section id="time-complexity" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="time-complexity"><span class="header-section-number">3.2</span> Time Complexity</h2>
<ul>
<li>Times: <img src="https://latex.codecogs.com/png.latex?O(n%5E2)"></li>
<li>Why: For each station, we simulate a full loop through all stations.</li>
<li>Scalability: This is too slow for large inputs (n up to 10⁵ in interviews or contests).</li>
</ul>
<p>In the next section, we’ll explore how to observe patterns in the problem and develop a greedy linear-time solution.</p>
</section>
</section>
<section id="greedy-approach-optimized-on-solution" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Greedy Approach (Optimized O(n) Solution)</h1>
<p>Now, let’s explore the <strong>efficient</strong> and <strong>elegant</strong> solution that solves the problem in <strong>O(n)</strong> time using greedy strategy.</p>
<hr>
<section id="key-observations" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="key-observations"><span class="header-section-number">4.1</span> Key Observations</h2>
<ol type="1">
<li>Let’s define:
<ul>
<li><code>gain[i] = gas[i] - cost[i]</code> — net fuel at station <code>i</code>.</li>
<li><code>total_tank = sum(gain)</code> — if it’s <strong>negative</strong>, no solution exists.</li>
</ul></li>
<li>If your <strong>current tank (<code>curr_tank</code>) drops below 0</strong> at station <code>i</code>, it means:
<ul>
<li>Any station between your last start and <code>i</code> cannot be the correct starting point.</li>
<li>So, you must <strong>reset your start point</strong> to <code>i + 1</code>.</li>
</ul></li>
</ol>
<hr>
</section>
<section id="step-by-step-algorithm" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="step-by-step-algorithm"><span class="header-section-number">4.2</span> Step-by-Step Algorithm</h2>
<ol type="1">
<li>Initialize:
<ul>
<li><code>total_tank = 0</code></li>
<li><code>curr_tank = 0</code></li>
<li><code>start_index = 0</code></li>
</ul></li>
<li>Loop through each station <code>i</code>:
<ul>
<li>Compute <code>gain = gas[i] - cost[i]</code></li>
<li>Update tanks:
<ul>
<li><code>total_tank += gain</code></li>
<li><code>curr_tank += gain</code></li>
</ul></li>
<li>If <code>curr_tank &lt; 0</code>, reset:
<ul>
<li><code>start_index = i + 1</code></li>
<li><code>curr_tank = 0</code></li>
</ul></li>
</ul></li>
<li>After the loop:
<ul>
<li>If <code>total_tank &gt;= 0</code>, return <code>start_index</code></li>
<li>Else, return <code>-1</code></li>
</ul></li>
</ol>
<hr>
</section>
<section id="why-it-works" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="why-it-works"><span class="header-section-number">4.3</span> Why It Works</h2>
<ul>
<li>If the <strong>total fuel</strong> is not enough to cover the total cost, no path is possible — simple elimination.</li>
<li>The greedy reset ensures we skip all impossible start points in a single pass.</li>
<li>Only <strong>1 loop</strong>, so time complexity is <strong>O(n)</strong>.</li>
</ul>
<hr>
</section>
<section id="code-implementation" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="code-implementation"><span class="header-section-number">4.4</span> Code Implementation</h2>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> can_complete_circuit(gas, cost):</span>
<span id="cb3-2">    total_tank <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb3-3">    curr_tank <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb3-4">    start_index <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb3-5"></span>
<span id="cb3-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(gas)):</span>
<span id="cb3-7">        gain <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> gas[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> cost[i]</span>
<span id="cb3-8">        total_tank <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> gain</span>
<span id="cb3-9">        curr_tank <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> gain</span>
<span id="cb3-10"></span>
<span id="cb3-11">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> curr_tank <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb3-12">            start_index <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb3-13">            curr_tank <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb3-14"></span>
<span id="cb3-15">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> start_index <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> total_tank <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span></code></pre></div>
<p>In the next section, we’ll visualize this approach step-by-step using a sample input and animation-style diagrams.</p>
</section>
</section>
<section id="visual-intuition-with-step-by-step-example" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Visual Intuition with Step-by-Step Example</h1>
<p>Let’s walk through a <strong>real example</strong> to internalize how the greedy solution works.</p>
<div class="quarto-video"><video id="video_shortcode_videojs_video1" class="video-js vjs-default-skin vjs-fluid" controls="" preload="auto" data-setup="{}" title=""><source src="videos/GasStationGreedyScene.mp4"></video></div>
</section>
<section id="interviewer-insight" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Interviewer Insight</h1>
<p>This is how we impress in an interview:</p>
<ul>
<li>Start with brute force: “Try all start stations.”</li>
<li>Then: “This is O(n²), we need better.”</li>
<li>Key Insight: “We only care about total fuel and where the tank drops below zero.”</li>
<li>Greedy Rule: “If the tank is ever negative, none of the stations before that can be the start.”</li>
</ul>
</section>
<section id="greedy-problem-solving-framework" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Greedy Problem Solving Framework</h1>
<p>Greedy algorithms solve problems by <strong>making locally optimal choices</strong> at each step in the hope that they lead to a <strong>globally optimal solution</strong>. However, <strong>not all problems can be solved greedily</strong>. Here’s a reliable framework to decide <strong>when and how to apply</strong> a greedy strategy.</p>
<hr>
<section id="problem-understanding" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="problem-understanding"><span class="header-section-number">7.1</span> Problem Understanding</h2>
<ul>
<li><strong>Goal</strong>: What is being optimized? (e.g., minimize cost, maximize profit)</li>
<li><strong>Constraints</strong>: Do choices need to be irreversible or done in order?</li>
<li><strong>Input Size</strong>: Is brute-force even feasible?</li>
</ul>
<hr>
</section>
<section id="brute-force-first" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="brute-force-first"><span class="header-section-number">7.2</span> Brute Force First</h2>
<ul>
<li>Try all possible paths/choices.</li>
<li>Ask: Why is this inefficient?</li>
<li>This helps reveal <em>structure</em> in the problem (e.g., repeated states, redundant decisions).</li>
</ul>
<hr>
</section>
<section id="identify-the-greedy-choice" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="identify-the-greedy-choice"><span class="header-section-number">7.3</span> Identify the “Greedy Choice”</h2>
<p>Ask: - What is the <em>best local decision</em> I can make at each step? - Can I prove that making this choice will <em>never hurt future decisions</em>?</p>
<p>Common greedy choices: - <strong>Max gain</strong> per step - <strong>Min cost</strong> to reach the next step - <strong>Earliest deadline</strong>, <strong>highest value per weight</strong>, etc.</p>
<hr>
</section>
<section id="validate-greedy-is-safe" class="level2" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="validate-greedy-is-safe"><span class="header-section-number">7.4</span> Validate Greedy is Safe</h2>
<p>Test your greedy choice with: - <strong>Counterexamples</strong>: Try inputs where greedy may fail. - <strong>Proof</strong>: Can you prove “greedy choice” leads to an optimal solution?</p>
<p>Techniques: - <strong>Exchange Argument</strong> - <strong>Greedy Stays Ahead</strong></p>
<hr>
</section>
<section id="implement-test" class="level2" data-number="7.5">
<h2 data-number="7.5" class="anchored" data-anchor-id="implement-test"><span class="header-section-number">7.5</span> Implement &amp; Test</h2>
<ul>
<li>Use <code>O(n)</code> or <code>O(n log n)</code> greedy logic.</li>
<li>Track accumulative values (e.g., balance, remaining capacity).</li>
<li>Reset conditions if necessary (like in gas station).</li>
</ul>
<hr>
</section>
<section id="common-greedy-patterns" class="level2" data-number="7.6">
<h2 data-number="7.6" class="anchored" data-anchor-id="common-greedy-patterns"><span class="header-section-number">7.6</span> Common Greedy Patterns</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>Pattern</th>
<th>Example Problems</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Interval Scheduling</td>
<td>Activity selection, meeting rooms</td>
</tr>
<tr class="even">
<td>Resource Allocation</td>
<td>Fractional knapsack</td>
</tr>
<tr class="odd">
<td>Accumulated Constraints</td>
<td>Gas Station, Jump Game</td>
</tr>
<tr class="even">
<td>Covering Problems</td>
<td>Set cover approximations</td>
</tr>
</tbody>
</table>
<hr>
</section>
<section id="mindset-summary" class="level2" data-number="7.7">
<h2 data-number="7.7" class="anchored" data-anchor-id="mindset-summary"><span class="header-section-number">7.7</span> Mindset Summary</h2>
<blockquote class="blockquote">
<p>“Make the best local decision… but <strong>prove</strong> or <strong>observe</strong> that it’s globally optimal.”</p>
</blockquote>
<p>Use greedy when: - Future choices don’t depend heavily on past ones - Local optimum leads to global optimum - Problem can be modeled with <strong>monotonic constraints</strong></p>
<hr>
<p><strong>Example</strong>: In the gas station problem<br>
- Greedy resets starting index when <code>curr_tank &lt; 0</code><br>
- If <code>total_tank &gt;= 0</code>, a valid start must exist<br>
- Greedy eliminates bad candidates efficiently</p>
<hr>
<p>Final Note:<br>
Not all problems are greedy-solvable. When in doubt, try: - Dynamic Programming - Backtracking with pruning</p>


</section>
</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-gas-station/</guid>
  <pubDate>Thu, 17 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Prime Digit Replacements</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/project-euler-prime-digit-replacements/</link>
  <description><![CDATA[ 




<section id="problem" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Problem</h1>
<p>By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.</p>
<p>By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003, being the first member of this family, is the smallest prime with this property.</p>
<p>Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.</p>
<div class="quarto-video"><video id="video_shortcode_videojs_video1" class="video-js vjs-default-skin vjs-fluid" controls="" preload="auto" data-setup="{}" title=""><source src="videos/PrimeFamily2Digit.mp4"></video></div>
<div class="quarto-video"><video id="video_shortcode_videojs_video2" class="video-js vjs-default-skin vjs-fluid" controls="" preload="auto" data-setup="{}" title=""><source src="videos/PrimeFamily56003.mp4"></video></div>
</section>
<section id="analysis" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Analysis</h1>
<p>The problem asks for the <strong>smallest prime</strong> that belongs to an <strong>8-prime value family</strong>.</p>
<p>This means: - Start with a prime number. - Replace one or more digits (not necessarily adjacent) that are the <em>same</em>, with a wildcard symbol like <code>*</code>. - Then, generate all possible numbers by replacing <code>*</code> with digits <code>0</code> through <code>9</code>. - Count how many of those are prime. - We want the <strong>first (smallest) such prime</strong> that produces <strong>at least 8 primes</strong> in this replacement process.</p>
<section id="why-the-solution-space-is-finite" class="level3" data-number="2.0.1">
<h3 data-number="2.0.1" class="anchored" data-anchor-id="why-the-solution-space-is-finite"><span class="header-section-number">2.0.1</span> Why the Solution Space Is Finite</h3>
<p>Although large, the space of numbers we need to search is <strong>finite</strong> because: - We’re looking for the <em>smallest</em> such prime. - The number of primes in each digit-length range is countable.</p>
</section>
<section id="constraints-that-help-reduce-the-search" class="level3" data-number="2.0.2">
<h3 data-number="2.0.2" class="anchored" data-anchor-id="constraints-that-help-reduce-the-search"><span class="header-section-number">2.0.2</span> Constraints That Help Reduce the Search</h3>
<ol type="1">
<li><p><strong>Only Repeated Digits Are Useful</strong><br>
We only attempt digit replacements on digits that appear multiple times in the number. Replacing unique digits can’t generate families of size &gt;1.</p></li>
<li><p><strong>Leading Zeros Are Invalid</strong><br>
If replacing the first digit results in a leading zero (e.g., <code>0xxxx</code>), it’s not a valid number, so we skip that case.</p></li>
<li><p><strong>We Only Consider Primes</strong><br>
Instead of checking all natural numbers, we loop through <strong>only primes</strong> — the valid candidates for the answer.</p></li>
</ol>
</section>
<section id="strategy-summary" class="level3" data-number="2.0.3">
<h3 data-number="2.0.3" class="anchored" data-anchor-id="strategy-summary"><span class="header-section-number">2.0.3</span> Strategy Summary</h3>
<p>This is essentially a <strong>targeted brute-force</strong> solution: - Try each prime one by one. - For each repeated digit, try all subsets of its positions. - Replace those positions with digits <code>0</code> to <code>9</code>, checking for primality. - Keep track of how many primes are generated in that “family”. - As soon as we find a family with 8 or more primes, we return the smallest member.</p>
<p>This systematic pruning makes the brute-force approach feasible.</p>
</section>
</section>
<section id="naive-approach---prime-digit-replacement-problem" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Naive Approach - Prime Digit Replacement Problem</h1>
<section id="problem-recap" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="problem-recap"><span class="header-section-number">3.1</span> Problem Recap</h2>
<p>We want to find the <strong>smallest prime number</strong> that, by <strong>replacing part of its digits</strong> (not necessarily adjacent) with the same <strong>digit</strong>, produces <strong>at least eight primes</strong> among the 10 generated numbers.</p>
</section>
<section id="naive-strategy" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="naive-strategy"><span class="header-section-number">3.2</span> Naive Strategy</h2>
<p>The problems explicitly mentions:</p>
<p>“the 5-digits number 56003 is the first example having seven primes…”</p>
<p>This tell us:</p>
<ul>
<li>Smaller numbers (1- to 4-digit) <strong>do not</strong> produce a 7-prime family</li>
<li>So the <strong>search for 8-prime families must begin at least from 5-digit numbers</strong></li>
</ul>
<ol type="1">
<li><p><strong>Loop through numbers starting from 10,000</strong> (since 5-digit numbers are known to be involved).</p></li>
<li><p>For each number:</p></li>
</ol>
<ul>
<li>Generate all combinations of digit positions to replace (1 or more digits).</li>
<li>For each combination:
<ul>
<li>Replace those positions with digits 0 → 9, one at a time.</li>
<li>Count how many of the resulting 10 numbers are prime.</li>
</ul></li>
<li>If ≥ 8 are prime → we’ve found our answer.</li>
</ul>
</section>
<section id="pseudo-code" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="pseudo-code"><span class="header-section-number">3.3</span> Pseudo code</h2>
<pre class="{pseudocode}"><code>for number in range(10000, 1000000):
    if not is_prime(number):
        continue

    digits = str(number)
    for mask in all possible combinations of positions:
        family = []
        for replacement_digit in '0123456789':
            candidate_digits = digits with mask replaced by replacement_digit
            if candidate starts with '0':
                continue
            if is_prime(candidate):
                family.append(candidate)
        if len(family) &gt;= 8:
            return number
</code></pre>
</section>
<section id="characteristics-of-naive-approach" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="characteristics-of-naive-approach"><span class="header-section-number">3.4</span> Characteristics of Naive Approach</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 37%">
<col style="width: 62%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Brute-force</strong></td>
<td>Tries every combination of positions and digits</td>
</tr>
<tr class="even">
<td><strong>Inefficient</strong></td>
<td>Loops over all numbers (not just primes)</td>
</tr>
<tr class="odd">
<td><strong>No digit filtering</strong></td>
<td>May replace digits that occur only once</td>
</tr>
<tr class="even">
<td><strong>Replaces non-equal digits</strong></td>
<td>Ignores structure of the problem</td>
</tr>
<tr class="odd">
<td><strong>Slow</strong></td>
<td>Explores huge space with many invalid candidates</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-rough-estimate" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="complexity-rough-estimate"><span class="header-section-number">3.5</span> Complexity (Rough Estimate)</h2>
<p>Let <em>n</em> be the number of digits (5-6 digits):</p>
<ul>
<li>Combinations of digit positions: <img src="https://latex.codecogs.com/png.latex?2%5En-1"></li>
<li>Replacements: 10 per pattern</li>
<li>Prime checks: up to <img src="https://latex.codecogs.com/png.latex?10%20%5Ctimes%20(2%5En%20-%201)"> per number</li>
</ul>
<p><strong>Overall complexity</strong></p>
<p><img src="https://latex.codecogs.com/png.latex?%0AO(N%5Ccdot2%5En%5Ccdot10%5Ccdot%5Ctext%7Bis%5C_prime%7D)%0A"></p>
<p>where <em>N</em> is the range of numbers tested (<img src="https://latex.codecogs.com/png.latex?10%5E6">)</p>
</section>
<section id="problem-with-naive" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="problem-with-naive"><span class="header-section-number">3.6</span> Problem with Naive</h2>
<ul>
<li>Wastes time replacing digits that occur only once</li>
<li>Replaces different digits at once (which isn’t allowed per the problem)</li>
<li>Replaces digits even when they don’t repeat</li>
<li>Explores non-primes too</li>
</ul>
</section>
</section>
<section id="structured-brute-force-approach" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Structured Brute Force Approach</h1>
<section id="motivation" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="motivation"><span class="header-section-number">4.1</span> Motivation</h2>
<p>The naive approach checks all numbers and all possible digit replacements. But this is very slow.</p>
<p>A more efficient method is to:</p>
<ul>
<li>Check <strong>only primes</strong></li>
<li>Replace only <strong>repeated digits</strong></li>
<li>Ensure no replacements create invalid numbers (like leading zero)</li>
<li>Stop early when we find the first family with 8 primes</li>
</ul>
<p>This gives us a <strong>structured brute-force solution</strong>.</p>
</section>
<section id="key-insights-over-naive-approach" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="key-insights-over-naive-approach"><span class="header-section-number">4.2</span> Key Insights Over Naive Approach</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>Improvement</th>
<th>Why It Helps</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Only check <strong>primes</strong></td>
<td>Non-primes can’t be part of the answer</td>
</tr>
<tr class="even">
<td>Only replace <strong>repeated digits</strong></td>
<td>You must replace the <strong>same digit</strong> (e.g.&nbsp;all <code>1</code>s or all <code>3</code>s)</td>
</tr>
<tr class="odd">
<td>Replace <strong>some (not all)</strong> of the repeated digits</td>
<td>Full replacement may cause invalid numbers (e.g.&nbsp;leading zero)</td>
</tr>
<tr class="even">
<td>Avoid replacement that starts with <code>0</code></td>
<td>Cannot have leading zero in base-10 integers</td>
</tr>
</tbody>
</table>
</section>
<section id="algorithm" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="algorithm"><span class="header-section-number">4.3</span> Algorithm</h2>
<section id="step-1-generate-all-primes-up-to-a-limit" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="step-1-generate-all-primes-up-to-a-limit"><span class="header-section-number">4.3.1</span> Step 1: Generate All Primes Up to a Limit</h3>
<p>Use a sieve to get all primes up to a reasonable upper bound (e.g., 1 million).</p>
</section>
<section id="step-2-for-each-prime" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="step-2-for-each-prime"><span class="header-section-number">4.3.2</span> Step 2: For each Prime</h3>
<ol type="1">
<li>Convert to String</li>
<li>For each digit <code>d</code> (from <code>'0'</code> to <code>'9'</code>):</li>
</ol>
<ul>
<li>Get positions where <code>d</code> appears more than once</li>
<li>Generate all non-empty subsets of those positions</li>
<li>Replace those positions with every digit <code>0–9</code></li>
<li>For each subset:
<ul>
<li>Replace those digits with value <code>0-9</code></li>
<li>Skip if the number starts with <code>'0'</code></li>
<li>Count how many of the resulting numbers are prime</li>
<li>If 8 or more primes found, return the original prime</li>
</ul></li>
</ul>
</section>
</section>
<section id="complexity" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="complexity"><span class="header-section-number">4.4</span> Complexity</h2>
<p>Let:</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?P">: number of primes (~ <img src="https://latex.codecogs.com/png.latex?10%5E5">)</li>
<li><img src="https://latex.codecogs.com/png.latex?D">: number of distinct digits (10)</li>
<li><img src="https://latex.codecogs.com/png.latex?S">: number of non-empty subsets per digit (usually <img src="https://latex.codecogs.com/png.latex?%5Cleq%2016">)</li>
<li><img src="https://latex.codecogs.com/png.latex?R">: replacements per subset (10 digits)</li>
</ul>
<p>Then:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AO(P%5Ccdot%20D%20%5Ccdot%20S%20%5Ccdot%20R)%0A"></p>
</section>
<section id="summary" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="summary"><span class="header-section-number">4.5</span> Summary</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Feature</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Improves over naive</td>
<td>Yes (skips non-primes, invalid cases)</td>
</tr>
<tr class="even">
<td>Fast enough in practice</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Understandable</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Prepares for deeper ideas</td>
<td>Yes</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="formal-modeling-and-optimization" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Formal Modeling and Optimization</h1>
<section id="goal" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="goal"><span class="header-section-number">5.1</span> Goal</h2>
<p>Find the <strong>smallest prime</strong> <code>p</code> such that <strong>replacing a subset of its digits</strong> (not necessarily adjacent) with the <strong>same digit <code>d</code></strong>, yields a <strong>family of 8+ prime numbers</strong> out of the 10 possible values.</p>
<p>We aim to go beyond brute-force by <strong>modeling</strong> the structure of this problem as a constrained optimization over symbolic patterns.</p>
</section>
<section id="step-1-abstract-the-problem-as-a-search-over-equivalence-classes" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="step-1-abstract-the-problem-as-a-search-over-equivalence-classes"><span class="header-section-number">5.2</span> Step 1: Abstract the Problem as a Search over Equivalence Classes</h2>
<p>We define:</p>
<ul>
<li>A <strong>prime template</strong>: a pattern like <code>'56**3'</code> where <code>*</code> is a wildcard</li>
<li>A <strong>family function</strong>: <img src="https://latex.codecogs.com/png.latex?%0AF(t)%20=%20%5C%7B%20%5Ctext%7Bfill%20in%20%7D%20*%20%5Ctext%7B%20in%20%7D%20t%20%5Ctext%7B%20with%20digits%20%7D%200..9%20%5C%7D%0A"></li>
</ul>
<p>We want:</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%7CF(t)%20%5Ccap%20%5Ctext%7BPRIMES%7D%7C%20%5Cgeq%208"></li>
<li>and to find the <strong>template</strong> <code>t</code> with smallest base value <code>min(F(t))</code> meeting the above</li>
</ul>
<hr>
</section>
<section id="step-2-symbolic-representation-of-digit-replacements" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="step-2-symbolic-representation-of-digit-replacements"><span class="header-section-number">5.3</span> Step 2: Symbolic Representation of Digit Replacements</h2>
<p>Let each prime <code>p</code> be treated as a string <code>s</code>, and let <code>S ⊂ \text{positions}(s)</code>.</p>
<p>We define a <strong>mask vector</strong> <code>m</code>:</p>
<ul>
<li><code>m[i] = 1</code> if index <code>i</code> is to be replaced</li>
<li><code>m[i] = 0</code> otherwise</li>
</ul>
<p>Now define a <strong>pattern class</strong>: <img src="https://latex.codecogs.com/png.latex?%0AT_%7Bp,m%7D%20=%20%5C%7B%20%5Ctext%7Breplace%20%7D%20s%5Bi%5D%20%5Ctext%7B%20where%20%7D%20m%5Bi%5D=1%20%5Ctext%7B%20with%20%7D%20d%20%5Cin%200..9%20%5C%7D%0A"></p>
<p>So the family is generated by iterating over all <code>d ∈ [0,9]</code>.</p>
<hr>
</section>
<section id="step-3-model-the-problem-as-an-optimization" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="step-3-model-the-problem-as-an-optimization"><span class="header-section-number">5.4</span> Step 3: Model the Problem as an Optimization</h2>
<section id="variables" class="level4">
<h4 class="anchored" data-anchor-id="variables">Variables:</h4>
<ul>
<li>Prime <code>p</code></li>
<li>Digit mask <code>m</code></li>
</ul>
</section>
<section id="constraints" class="level4">
<h4 class="anchored" data-anchor-id="constraints">Constraints:</h4>
<ul>
<li>Positions masked must contain the <strong>same digit</strong></li>
<li>Leading digit after replacement ≠ <code>0</code></li>
<li>At least 8 of the 10 generated numbers are <strong>prime</strong></li>
</ul>
</section>
<section id="objective" class="level4">
<h4 class="anchored" data-anchor-id="objective">Objective:</h4>
<ul>
<li>Minimize <code>p</code> such that: <img src="https://latex.codecogs.com/png.latex?%0A%5Cleft%7C%20F(p,%20m)%20%5Ccap%20%5Ctext%7BPRIMES%7D%20%5Cright%7C%20%5Cgeq%208%0A"></li>
</ul>
<hr>
</section>
</section>
<section id="step-4-optimizations-based-on-number-theory" class="level2" data-number="5.5">
<h2 data-number="5.5" class="anchored" data-anchor-id="step-4-optimizations-based-on-number-theory"><span class="header-section-number">5.5</span> Step 4: Optimizations Based on Number Theory</h2>
<section id="digit-frequency-filtering" class="level4">
<h4 class="anchored" data-anchor-id="digit-frequency-filtering">1. <strong>Digit Frequency Filtering</strong></h4>
<ul>
<li>Only consider digits that repeat at least twice in the prime</li>
<li>Avoid replacing rare digits</li>
</ul>
</section>
<section id="modulo-pruning" class="level4">
<h4 class="anchored" data-anchor-id="modulo-pruning">2. <strong>Modulo Pruning</strong></h4>
<ul>
<li>Skip candidates that will generate multiples of 2 or 5 in replacement</li>
</ul>
</section>
<section id="avoid-unnecessary-masks" class="level4">
<h4 class="anchored" data-anchor-id="avoid-unnecessary-masks">3. <strong>Avoid Unnecessary Masks</strong></h4>
<ul>
<li>Skip full replacements</li>
<li>Skip replacements that break positional value (e.g., fixed ending <code>1</code>, <code>3</code>, <code>7</code>, <code>9</code> often more promising)</li>
</ul>
<hr>
</section>
</section>
<section id="step-5-search-as-constrained-enumeration" class="level2" data-number="5.6">
<h2 data-number="5.6" class="anchored" data-anchor-id="step-5-search-as-constrained-enumeration"><span class="header-section-number">5.6</span> Step 5: Search as Constrained Enumeration</h2>
<p>We now enumerate over primes:</p>
<ul>
<li>For each prime, extract repeated digit positions</li>
<li>For each digit <code>d</code>, generate all valid <code>mask</code> subsets where digit <code>d</code> occurs</li>
<li>Build replacement families</li>
<li>Use <strong>fast primality tests</strong>, and stop early if a mask yields ≥ 8 primes</li>
</ul>
<p>This avoids full combinatorial enumeration, and uses <strong>structure + constraint filtering</strong> to reduce search space.</p>
<hr>
</section>
<section id="theoretical-complexity" class="level2" data-number="5.7">
<h2 data-number="5.7" class="anchored" data-anchor-id="theoretical-complexity"><span class="header-section-number">5.7</span> Theoretical Complexity</h2>
<p>Compared to brute force:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 61%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Prime generation</td>
<td><img src="https://latex.codecogs.com/png.latex?O(n%20%5Clog%20%5Clog%20n)"></td>
</tr>
<tr class="even">
<td>Mask enumeration</td>
<td>Reduced from <img src="https://latex.codecogs.com/png.latex?2%5Ek"> to only valid repeated-digit subsets</td>
</tr>
<tr class="odd">
<td>Replacement testing</td>
<td><img src="https://latex.codecogs.com/png.latex?10%20%5Ctimes%20k"> per valid mask</td>
</tr>
<tr class="even">
<td>Primality test</td>
<td><img src="https://latex.codecogs.com/png.latex?O(%5Csqrt%7Bn%7D)"> or Miller–Rabin in <img src="https://latex.codecogs.com/png.latex?O(%5Clog%5E3%20n)"></td>
</tr>
</tbody>
</table>
<p>→ Net result: <strong>Much faster and scalable</strong>, with full mathematical transparency.</p>
<hr>
</section>
<section id="phd-level-interpretation" class="level2" data-number="5.8">
<h2 data-number="5.8" class="anchored" data-anchor-id="phd-level-interpretation"><span class="header-section-number">5.8</span> PhD-Level Interpretation</h2>
<p>This transforms the problem into:</p>
<blockquote class="blockquote">
<p>A <strong>symbolic family detection</strong> problem over the space of integers, using digit-based constraints and algebraic structure.</p>
</blockquote>
<p>Possible future work includes: - Pattern mining via SAT/SMT solvers - Probabilistic modeling of family distributions - Generalizing to <code>k</code>-prime families</p>
<hr>
</section>
<section id="summary-1" class="level2" data-number="5.9">
<h2 data-number="5.9" class="anchored" data-anchor-id="summary-1"><span class="header-section-number">5.9</span> Summary</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Feature</th>
<th>PhD Model</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Abstraction</td>
<td>Symbolic patterns over digits</td>
</tr>
<tr class="even">
<td>Constraints</td>
<td>Digit repetition, prime count, no leading 0</td>
</tr>
<tr class="odd">
<td>Objective</td>
<td>Minimize base prime <code>p</code></td>
</tr>
<tr class="even">
<td>Tools</td>
<td>Digit masks, primality testing, search space pruning</td>
</tr>
<tr class="odd">
<td>Outcome</td>
<td>Structured, fast, extensible method</td>
</tr>
</tbody>
</table>
<hr>
<p>This approach not only solves the problem but provides a <strong>reusable framework</strong> for other “digit-replacement” or “prime-pattern” problems in computational number theory.</p>


</section>
</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/project-euler-prime-digit-replacements/</guid>
  <pubDate>Wed, 16 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>45. Jump Game II</title>
  <dc:creator>Hung </dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-jump-game-2/</link>
  <description><![CDATA[ 




<section id="problem-jump-game-ii" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Problem: Jump Game II</h1>
<p>You are given a <strong>0-indexed</strong> array of integers <code>nums</code> of length <code>n</code>. You are initially positioned at <code>nums[0]</code>.</p>
<p>Each element <code>nums[i]</code> represents the <strong>maximum length of a forward jump</strong> from index <code>i</code>. In other words, if you are at <code>nums[i]</code>, you can jump to any <code>nums[i + j]</code> where:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code>, and<br>
</li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>Return the <strong>minimum number of jumps</strong> to reach <code>nums[n - 1]</code>.</p>
<p>The test cases are generated such that <strong>you can reach <code>nums[n - 1]</code></strong>.</p>
<hr>
<section id="examples" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="examples"><span class="header-section-number">1.1</span> Examples</h2>
<p><strong>Example 1:</strong></p>
<pre><code>Input:  nums = [2, 3, 1, 1, 4]
Output: 2
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input:  nums = [2, 3, 0, 1, 4]
Output: 2</code></pre>
<hr>
</section>
<section id="constraints" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="constraints"><span class="header-section-number">1.2</span> Constraints</h2>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10⁴</code><br>
</li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code><br>
</li>
<li>It is guaranteed that you can reach <code>nums[n - 1]</code>.</li>
</ul>
</section>
</section>
<section id="approaches" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Approaches</h1>
<p><strong>Problem Summary:</strong></p>
<p>You are given a 0-indexed array <code>nums</code> where each element represents the maximum jump length you can make from that position. Starting at index 0, your goal is to reach the last index with the <strong>minimum number of jumps</strong>.</p>
<p>Example:</p>
<pre class="text"><code>Input:  nums = [2, 3, 1, 1, 4]
Output: 2
Explanation: Jump from 0 → 1, then from 1 → 4.</code></pre>
<hr>
<section id="initial-intuition-dynamic-programming-approach" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="initial-intuition-dynamic-programming-approach"><span class="header-section-number">2.1</span> Initial Intuition (Dynamic Programming Approach)</h2>
<p>As a beginner, one natural way to approach this is to <strong>track the minimum number of jumps</strong> needed to reach each index. We can use an auxiliary array <code>min_step[]</code>, where:</p>
<ul>
<li><code>min_step[i]</code> = the <strong>minimum number of steps</strong> to reach index <code>i</code> from index <code>0</code>.</li>
</ul>
<section id="pseudocode" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="pseudocode"><span class="header-section-number">2.1.1</span> Pseudocode</h3>
<ol type="1">
<li>Initialize <code>min_step[0] = 0</code>, and others as 0 (we’ll treat 0 as “unvisited”).</li>
<li>For each index <code>i</code>, simulate all possible forward jumps up to <code>nums[i]</code>.</li>
<li>For each reachable index <code>i + step</code>, update <code>min_step[i + step]</code> if it hasn’t been visited.</li>
</ol>
</section>
<section id="visualization" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="visualization"><span class="header-section-number">2.1.2</span> Visualization</h3>
<div class="quarto-video"><video id="video_shortcode_videojs_video1" class="video-js vjs-default-skin vjs-fluid" controls="" preload="auto" data-setup="{}" title=""><source src="videos/JumpGameDPApproach2.mp4"></video></div>
</section>
<section id="python-code" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="python-code"><span class="header-section-number">2.1.3</span> Python Code</h3>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> typing <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> List</span>
<span id="cb4-2"></span>
<span id="cb4-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Solution:</span>
<span id="cb4-4">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> jump(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, nums: List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>:</span>
<span id="cb4-5">        n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums)</span>
<span id="cb4-6">        min_step <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> n  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># min_step[i]: min jumps to reach index i</span></span>
<span id="cb4-7"></span>
<span id="cb4-8">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n):</span>
<span id="cb4-9">            steps <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nums[i]</span>
<span id="cb4-10">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> step <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, steps <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):</span>
<span id="cb4-11">                next_pos <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> step</span>
<span id="cb4-12">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> next_pos <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> n <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> min_step[next_pos] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>: <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># bound and visited</span></span>
<span id="cb4-13">                    min_step[next_pos] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> min_step[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb4-14"></span>
<span id="cb4-15">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> min_step[n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]</span></code></pre></div>
<hr>
</section>
</section>
<section id="time-space-complexity" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="time-space-complexity"><span class="header-section-number">2.2</span> Time &amp; Space Complexity</h2>
<ul>
<li><strong>Time:</strong> O(n²) in the worst case (if every <code>nums[i]</code> is large and we simulate many jumps).</li>
<li><strong>Space:</strong> O(n) for the <code>min_step[]</code> array.</li>
</ul>
<section id="pros" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="pros"><span class="header-section-number">2.2.1</span> Pros</h3>
<ul>
<li>Can AC in leetcode.</li>
<li>Easy to understand and implement.</li>
<li>Helps build dynamic programming intuition.</li>
</ul>
</section>
<section id="cons" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="cons"><span class="header-section-number">2.2.2</span> Cons</h3>
<ul>
<li>Too slow for large arrays (e.g.&nbsp;<code>n = 10⁴</code>).</li>
<li>Redundant work — we revisit the same states multiple times.</li>
</ul>
<hr>
</section>
</section>
<section id="the-optimal-greedy-approach-on" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="the-optimal-greedy-approach-on"><span class="header-section-number">2.3</span> The Optimal Greedy Approach (O(n))</h2>
<p>Once you’re comfortable with the basic idea, you can switch to a <strong>greedy</strong> strategy:</p>
<ol type="1">
<li>Track the <strong>farthest index</strong> reachable in the current “jump”.</li>
<li>When you reach the end of the current jump range, increment your jump count and update the next jump range.</li>
<li>Repeat until the end of the array is reachable.</li>
</ol>
<section id="visualization-1" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="visualization-1"><span class="header-section-number">2.3.1</span> Visualization</h3>
<div class="quarto-video"><video id="video_shortcode_videojs_video2" class="video-js vjs-default-skin vjs-fluid" controls="" preload="auto" data-setup="{}" title=""><source src="videos/JumpGameGreedy.mp4"></video></div>
</section>
<section id="optimal-code-greedy" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="optimal-code-greedy"><span class="header-section-number">2.3.2</span> Optimal Code (Greedy)</h3>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Solution:</span>
<span id="cb5-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> jump(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, nums: List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>:</span>
<span id="cb5-3">        jumps <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb5-4">        farthest <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb5-5">        current_end <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb5-6"></span>
<span id="cb5-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># exclude last index</span></span>
<span id="cb5-8">            farthest <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(farthest, i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> nums[i])</span>
<span id="cb5-9">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> current_end:</span>
<span id="cb5-10">                jumps <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb5-11">                current_end <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> farthest</span>
<span id="cb5-12">        </span>
<span id="cb5-13">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> jumps</span></code></pre></div>
<ul>
<li><strong>Time Complexity:</strong> O(n)</li>
<li><strong>Space Complexity:</strong> O(1)</li>
</ul>
<hr>
</section>
</section>
<section id="takeaways" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="takeaways"><span class="header-section-number">2.4</span> Takeaways</h2>
<ul>
<li>Your DP-style intuition is a great starting point for understanding how to model state transitions.</li>
<li>But always analyze the time complexity — for real-world coding problems, <strong>efficiency matters</strong>.</li>
<li>Learn to identify when a <strong>greedy strategy</strong> can replace DP in <strong>minimum step problems</strong>.</li>
</ul>
<hr>
</section>
<section id="learning-tip" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="learning-tip"><span class="header-section-number">2.5</span> Learning Tip</h2>
<p>Start by solving problems with a safe brute-force or DP mindset. Once you understand the pattern, look for greedy optimizations to reduce time complexity.</p>
<p>Happy coding! 💻</p>


</section>
</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-jump-game-2/</guid>
  <pubDate>Wed, 16 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Maximum subarray problem and Kadane’s algorithm</title>
  <dc:creator>Hung </dc:creator>
  <link>https://kimhungbui.github.io/programming/maximum-subarray-problem/</link>
  <description><![CDATA[ 




<p><img src="https://kimhungbui.github.io/programming/maximum-subarray-problem/Pasted image 20250602105019.png" class="img-fluid"></p>
<p>In computer science, the maximum sum subarray problem, also known as the maximum segment sum problem, is the task of finding a contiguous subarray with the largest sum, within a given one-dimensional array <code>A[1...n]</code> of numbers. It can be solved in <img src="https://latex.codecogs.com/png.latex?O(n)"> time and <img src="https://latex.codecogs.com/png.latex?O(1)"> space.</p>
<p>Formally, the task is to find indices <img src="https://latex.codecogs.com/png.latex?i"> and <img src="https://latex.codecogs.com/png.latex?j"> with <img src="https://latex.codecogs.com/png.latex?1%5Cleq%20i%20%5Cleq%20j%20%5Cleq%20n"> such that the sum <img src="https://latex.codecogs.com/png.latex?%0A%5CSigma%5Ej_%7Bx=i%7DA%5Bx%5D%0A"> is as large as possible</p>
<section id="application" class="level1">
<h1>Application</h1>
<p>Maximum subarray problems arise in many fields, such as genomic sequence analysis and computer vision.</p>
<p>Genomic sequence analysis employs maximum subarray algorithms to identify important biological segments of protein sequences that have unusual properties, by assigning scores to points within the sequence that are positive when a motif to be recognized is present, and negative when it is not, and then seeking the maximum subarray among these scores. These problems include conserved segments, GC-rich regions, tandem repeats, low-complexity filter, DNA binding domains, and regions of high charge.</p>
<p>In computer vision, bitmap images generally consist only of positive values, for which the maximum subarray problem is trivial: the result is always the whole array. However, after subtracting a threshold value (such as the average pixel value) from each pixel, so that above-average pixels will be positive and below-average pixels will be negative, the maximum subarray problem can be applied to the modified image to detect bright areas within it.</p>
</section>
<section id="kadanes-algorithm" class="level1">
<h1>Kadane’s algorithm</h1>
<section id="brute-force-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="brute-force-thoughts">Brute-Force Thoughts</h2>
<p>A naive way to find the maximum subarray is:</p>
<ol type="1">
<li><p>Enumerate all pairs of indices <code>(i, j)</code> with <code>0 ≤ i ≤ j &lt; n</code>.</p></li>
<li><p>Compute the sum of <code>array[i..j]</code>.</p></li>
<li><p>Track the largest sum seen.</p></li>
</ol>
<p>That requires <img src="https://latex.codecogs.com/png.latex?O(n%5E2)"> subarrays and, if we sum each subarray from scratch, up to <img src="https://latex.codecogs.com/png.latex?O(n)"> per sum, yielding <img src="https://latex.codecogs.com/png.latex?O(n%5E3)"> time. We can improve one factor to <img src="https://latex.codecogs.com/png.latex?O(n%5E2)"> by keeping a running sum when extending the end index, but that’s still too slow when <code>n</code> is large.</p>
<p>We want something like <img src="https://latex.codecogs.com/png.latex?O(n)"> time.</p>
<hr>
</section>
<section id="key-observation-intuition" class="level2">
<h2 class="anchored" data-anchor-id="key-observation-intuition">Key Observation (Intuition)</h2>
<blockquote class="blockquote">
<p><strong>Observation:</strong> Suppose you want to know “What is the maximum-sum subarray that ends exactly at index i?” Once you know that, you could check all i and pick the best among them.</p>
</blockquote>
<ul>
<li><p>Define<br>
<img src="https://latex.codecogs.com/png.latex?dp%5Bi%5D%20=%20%5Ctext%7Bthe%20maximum%20subarray%20sum%20among%20all%20subarrays%20that%20end%20at%20index%20%7Di."> Our ultimate answer (global max) will be<br>
<img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Cmax_%7B0%20%5Cle%20k%20%3C%20n%7D%20dp%5Bk%5D.%0A"></p></li>
<li><p>How do we compute <code>dp[i]</code> if we already know <code>dp[i–1]</code>? Consider any subarray that ends at i. It either:</p>
<ol type="1">
<li>Is just the single element <code>array[i]</code> (i.e., we “start fresh” at i), or<br>
</li>
<li>Is some subarray that ended at i−1 plus <code>array[i]</code> (i.e., we <strong>extend</strong> the best ending at i−1).</li>
</ol>
<p>In other words: <img src="https://latex.codecogs.com/png.latex?%0A%20%20dp%5Bi%5D%20%5C;=%5C;%20%5Cmax%5Cbigl(%5C;%20array%5Bi%5D,%5C;%20dp%5Bi-1%5D%20+%20array%5Bi%5D%20%5Cbigr).%0A"></p>
<ul>
<li>If <code>dp[i-1]</code> (the best ending at i−1) is negative, then we’re better off “dropping” it and taking <code>array[i]</code> alone.</li>
<li>If <code>dp[i-1]</code> is positive (or zero), then extending it by adding <code>array[i]</code> only makes the sum larger.</li>
</ul></li>
</ul>
<p>That recurrence is exactly Kadane’s idea.</p>
<hr>
</section>
<section id="deriving-kadanes-recurrence" class="level2">
<h2 class="anchored" data-anchor-id="deriving-kadanes-recurrence">Deriving Kadane’s Recurrence</h2>
<ol type="1">
<li><p><strong>Define</strong><br>
<img src="https://latex.codecogs.com/png.latex?dp%5Bi%5D%20=%20%5Ctext%7Bmax%20subarray%20sum%20ending%20exactly%20at%20index%20%7Di."></p></li>
<li><p><strong>Base case</strong>:<br>
<img src="https://latex.codecogs.com/png.latex?dp%5B0%5D%20=%20array%5B0%5D."></p></li>
<li><p><strong>Transition</strong>: For each (i ), consider two possibilities for the subarray that ends at (i):</p>
<ul>
<li><strong>Start a new subarray</strong> at (i). Its sum is (array[i]).<br>
</li>
<li><strong>Extend</strong> the best subarray ending at (i-1) by including the element at (i). Its sum is (dp[i-1] + array[i]).</li>
</ul>
<p>Therefore: <img src="https://latex.codecogs.com/png.latex?%0A%20%20dp%5Bi%5D%20=%20%5Cmax%5Cbigl(array%5Bi%5D,%5C,%20dp%5Bi-1%5D%20+%20array%5Bi%5D%5Cbigr).%0A"></p></li>
<li><p><strong>Global answer</strong>: As you fill these in from (i = 0) up to (n-1), keep track of <img src="https://latex.codecogs.com/png.latex?%0A%20%20%5Ctext%7Bglobal%5C_max%7D%20=%20%5Cmax_%7B0%20%5Cle%20k%20%3C%20n%7D%20dp%5Bk%5D.%0A"> That is the maximum sum among all possible ending-at-k subarrays, which necessarily includes the overall best subarray.</p></li>
</ol>
<p>Because computing each <code>dp[i]</code> takes O(1) time, the entire process is O(n).</p>
<hr>
</section>
<section id="intuitive-explanation" class="level2">
<h2 class="anchored" data-anchor-id="intuitive-explanation">Intuitive Explanation</h2>
<ul>
<li><p>As you sweep from left to right, maintain two values:</p>
<ol type="1">
<li><code>current_max</code> = “best subarray sum ending exactly at the current position.”</li>
<li><code>global_max</code> = “best subarray sum seen so far anywhere.”</li>
</ol></li>
<li><p>When you arrive at a new element <code>x = array[i]</code>, ask yourself:<br>
&gt; “If I want to pick a subarray that ends at i, is it better to (a) start fresh at i (just take x), or (b) stick with the best contiguous sum I had ending at i−1 and add x to it?”</p>
<ul>
<li>If the best sum ending at i−1 was negative, adding x would only make it worse than just taking x alone.<br>
</li>
<li>If the best sum ending at i−1 was positive, adding x can only help (or at least not make it smaller than x).</li>
</ul>
<p>Concretely:</p>
<pre class="plaintext"><code>current_max = max(x, current_max + x)
global_max  = max(global_max, current_max)</code></pre></li>
</ul>
<p>and then move on to i+1.</p>
<p>Think of it like this: whenever the running sum (best-ending-here) dips below zero, you toss it away and start over at the next index, because any prefix with negative sum would only drag down whatever comes after.</p>
<pre><code>function Kadane(array):
    if array is empty:
        return 0   // or some convention (e.g. negative infinity) depending on the problem

    current_max = array[0]
    global_max  = array[0]

    for i from 1 to (n - 1):
        x = array[i]
        // Either extend the previous best subarray, or start new at i
        current_max = max(x, current_max + x)

        // Update global answer if needed
        global_max = max(global_max, current_max)

    return global_max</code></pre>
<p>Initialization: We set both current_max and global_max to array[0]. That handles the case where all numbers might be negative: the answer is the single largest element.</p>
<p>Loop: At each step, update current_max using the recurrence. Then, if the new current_max is higher than any global_max we’ve seen so far, update global_max.</p>
<p>Return: By the end, global_max holds the largest sum of any contiguous subarray in the whole array.</p>
</section>
<section id="worked-example" class="level2">
<h2 class="anchored" data-anchor-id="worked-example">Worked Example</h2>
<p>Take the array <code>[-2, 1, -3, 4, -1, 2, 1, -5, 4]</code>. Walk through Kadane’s steps:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 2%">
<col style="width: 8%">
<col style="width: 19%">
<col style="width: 58%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">i</th>
<th style="text-align: center;">array[i]</th>
<th style="text-align: center;">current_max (before)</th>
<th style="text-align: center;">current_max (after) = max(array[i], current_max₍i−1₎ + array[i])</th>
<th style="text-align: center;">global_max</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">−2</td>
<td style="text-align: center;">(init) −2</td>
<td style="text-align: center;">max(−2, —) = −2</td>
<td style="text-align: center;">−2</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">+1</td>
<td style="text-align: center;">−2</td>
<td style="text-align: center;">max( 1, (−2 + 1) = −1 ) = 1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">−3</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">max(−3, (1 + (−3)) = −2 ) = −2</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">+4</td>
<td style="text-align: center;">−2</td>
<td style="text-align: center;">max( 4, (−2 + 4) = 2 ) = 4</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">−1</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">max(−1, (4 + (−1)) = 3 ) = 3</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">+2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">max( 2, (3 + 2) = 5 ) = 5</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">6</td>
<td style="text-align: center;">+1</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">max( 1, (5 + 1) = 6 ) = 6</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="even">
<td style="text-align: center;">7</td>
<td style="text-align: center;">−5</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">max(−5, (6 + (−5)) = 1 ) = 1</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">8</td>
<td style="text-align: center;">+4</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">max( 4, (1 + 4) = 5 ) = 5</td>
<td style="text-align: center;">6</td>
</tr>
</tbody>
</table>
<p>At index 6, <code>current_max</code> becomes 6, and that’s the largest sum observed. Indeed, subarray <code>[4, −1, 2, 1]</code> ends at i=6 and has sum 6.</p>
<p>By index 7, adding −5 would drop the running sum to 1, but since 1 is still ≥ −5 itself, Kadane chooses 1 (i.e., “extend” rather than “start new”).</p>
<p>By index 8, it’s better to start new at 8 or to extend the 1? We compare:</p>
<ul>
<li><strong>“Start new”</strong> at 8: sum = 4</li>
<li><strong>“Extend previous”</strong> (which was 1): sum = 1 + 4 = 5</li>
</ul>
<p>→ so we pick 5. However, 5 &lt; global_max = 6, so <code>global_max</code> remains 6.</p>
<hr>
</section>
<section id="handling-all-negative-arrays" class="level2">
<h2 class="anchored" data-anchor-id="handling-all-negative-arrays">Handling All-Negative Arrays</h2>
<p>A common question: “What if the array is entirely negative, e.g.&nbsp;<code>[-5, -3, -8]</code>?”<br>
Kadane’s initialization of</p>
<pre><code>current_max = global_max = array[0]</code></pre>
<p>automatically handles that. We never zero out a running sum unless it’s worse than starting fresh. So if all numbers are negative, every time you consider a new element <code>x</code>, you compute</p>
<pre><code>current_max = max(x, current_max + x)</code></pre>
<p>Since <code>current_max + x</code> is even more negative than <code>x</code> alone, the recurrence forces <code>current_max</code> to be the largest single negative element encountered so far. Thus the global max ends up being the least-negative (i.e., the “largest”) element of the array.</p>
<hr>
</section>
<section id="final-remarks" class="level2">
<h2 class="anchored" data-anchor-id="final-remarks">Final Remarks</h2>
<ul>
<li><strong>Time complexity</strong>: O(n), since each element is processed exactly once with O(1) work per element.</li>
<li><strong>Space complexity</strong>: O(1) extra space if you only keep two scalars (<code>current_max</code>, <code>global_max</code>). (If you store the entire <code>dp[]</code> array, it’s O(n), but you don’t need to; you only ever use the “previous” value.)</li>
</ul>
<p>Kadane’s algorithm is essentially a specialized form of dynamic programming that keeps track of a “running best suffix sum” and resets whenever that suffix sum would be negative. Once you grasp that the maximum-sum subarray ending at i is either “continue from i−1” or “start anew at i,” the rest follows naturally.</p>


</section>
</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/maximum-subarray-problem/</guid>
  <pubDate>Mon, 02 Jun 2025 00:00:00 GMT</pubDate>
  <media:content url="https://kimhungbui.github.io/programming/maximum-subarray-problem/Pasted%20image%2020250602105019.png" medium="image" type="image/png"/>
</item>
<item>
  <title>127. Word Ladder</title>
  <dc:creator>Hung </dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-word-ladder/</link>
  <description><![CDATA[ 




<p>A transformation sequence from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that:</p>
<ul>
<li>Every adjacent pair of words differs by a single letter.</li>
<li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>
<li><code>sk == endWord</code> Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return the number of words in the shortest transformation sequence from <code>beginWord</code> to <code>endWord</code>, or <code>0</code> if no such sequence exists.`</li>
</ul>
<p>Example 1:</p>
<pre><code>Input: `beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]`
Output: `5`
Explanation: `One shortest transformation sequence is "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; cog", which is 5 words long.`</code></pre>
<p>Example 2:</p>
<pre><code>Input: `beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]`
Output: `0`
Explanation: `The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.`</code></pre>
<p>Constraints:</p>
<p>1 &lt;= beginWord.length &lt;= 10 endWord.length == beginWord.length 1 &lt;= wordList.length &lt;= 5000 wordList[i].length == beginWord.length beginWord, endWord, and wordList[i] consist of lowercase English letters. beginWord != endWord All the words in wordList are unique.</p>
<section id="analysis" class="level1">
<h1>Analysis</h1>
<p>Have you ever tried to transform one word into another—one letter at a time—while only stepping through real English words? That’s the classic <strong>Word Ladder</strong> puzzle, and it’s exactly what LeetCode’s <strong>Ladder Length</strong> problem asks us to solve. In this blog post, we’ll walk through:</p>
<ol type="1">
<li><strong>Why BFS (Breadth-First Search) is the perfect fit</strong><br>
</li>
<li><strong>What goes wrong with a naïve backtracking approach</strong><br>
</li>
<li><strong>The clean, efficient BFS solution</strong></li>
</ol>
<hr>
<section id="the-pitfalls-of-naïve-backtracking" class="level2">
<h2 class="anchored" data-anchor-id="the-pitfalls-of-naïve-backtracking">2. The Pitfalls of Naïve Backtracking</h2>
<p>It’s tempting to reach for a simple recursive strategy:</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> ladderLength_naive(begin, end, word_dict):</span>
<span id="cb3-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> backtrack(current, remaining, depth):</span>
<span id="cb3-3">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> end:</span>
<span id="cb3-4">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> depth</span>
<span id="cb3-5">        best <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'inf'</span>)</span>
<span id="cb3-6">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> word <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">list</span>(remaining):</span>
<span id="cb3-7">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># only recurse on one-letter neighbors</span></span>
<span id="cb3-8">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sum</span>(a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> b <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> a,b <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">zip</span>(current, word)) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:</span>
<span id="cb3-9">                remaining.remove(word)</span>
<span id="cb3-10">                cand <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> backtrack(word, remaining, depth <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb3-11">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> cand:</span>
<span id="cb3-12">                    best <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(best, cand)</span>
<span id="cb3-13">                remaining.add(word)</span>
<span id="cb3-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> best <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> best <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'inf'</span>) <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb3-15"></span>
<span id="cb3-16">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> backtrack(begin, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">set</span>(word_dict), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span></code></pre></div>
<p><strong>Why it stumbles</strong> 1. Exponential Recursion Every choice spawns a new branch, and many branches share subproblems—leading to redundant work.</p>
<ol start="2" type="1">
<li><p>No Early Stopping You might explore a deep chain long after a shorter route exists elsewhere.</p></li>
<li><p>Backtracking Overhead Adding/removing words from the working set at each step is costly and easy to get wrong.</p></li>
</ol>
<p>In practice, this approach chokes on even modestly sized dictionaries.</p>
<hr>
</section>
</section>
<section id="the-sleek-bfs-solution" class="level1">
<h1>3. The Sleek BFS Solution</h1>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> collections <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> deque</span>
<span id="cb4-2"></span>
<span id="cb4-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Solution:</span>
<span id="cb4-4">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> ladderLength(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, begin: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">str</span>, end: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">str</span>, word_dict: List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">str</span>]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>:</span>
<span id="cb4-5">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Quick reject if 'end' is unreachable</span></span>
<span id="cb4-6">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> end <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">not</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> word_dict <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> begin <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> end:</span>
<span id="cb4-7">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb4-8"></span>
<span id="cb4-9">        word_set <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">set</span>(word_dict)</span>
<span id="cb4-10">        word_set.add(end)</span>
<span id="cb4-11">        visited <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {begin}</span>
<span id="cb4-12">        queue <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> deque([(begin, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)])  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># (current_word, steps_so_far)</span></span>
<span id="cb4-13"></span>
<span id="cb4-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">while</span> queue:</span>
<span id="cb4-15">            word, steps <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> queue.popleft()</span>
<span id="cb4-16">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> word <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> end:</span>
<span id="cb4-17">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> steps</span>
<span id="cb4-18"></span>
<span id="cb4-19">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Try changing each character to every 'a'–'z'</span></span>
<span id="cb4-20">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(word)):</span>
<span id="cb4-21">                original <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> word[i]</span>
<span id="cb4-22">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> c <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'abcdefghijklmnopqrstuvwxyz'</span>:</span>
<span id="cb4-23">                    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> original:</span>
<span id="cb4-24">                        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">continue</span></span>
<span id="cb4-25">                    candidate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> word[:i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> word[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:]</span>
<span id="cb4-26">                    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> candidate <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> word_set <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> candidate <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">not</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> visited:</span>
<span id="cb4-27">                        visited.add(candidate)</span>
<span id="cb4-28">                        queue.append((candidate, steps <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>))</span>
<span id="cb4-29"></span>
<span id="cb4-30">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span></code></pre></div>
<p><strong>Key Advantages</strong> - O(1) Lookups in both word_set and visited</p>
<ul>
<li><p>Single Visit per valid word</p></li>
<li><p>Guaranteed Shortest Path by BFS layering</p></li>
</ul>
<p>In terms of complexity, each of the up-to-26 letter-swaps per position in each word is checked only once per word, yielding O(N · L · 26) time (where N is dictionary size and L is word length) and O(N) space.</p>
</section>
<section id="wrapping-up" class="level1">
<h1>4. Wrapping Up</h1>
<p>When you need the shortest transformation in an unweighted graph—whether it’s words, grid cells, or social-network connections—BFS should be your first thought. Naïve recursion might look neat on paper, but real-world constraints demand the efficiency and crisp guarantees that BFS + a visited set provides.</p>
<p>Happy coding, and may all your word ladders be short! 🚀</p>


</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-word-ladder/</guid>
  <pubDate>Fri, 30 May 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>2359. Find Closest Node to Given Two Nodes</title>
  <dc:creator>Hung </dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-find-closest-node-given-2-nodes/</link>
  <description><![CDATA[ 




<p>Topic: <code>Graph, Deep-First Search</code></p>
<section id="question" class="level1">
<h1>Question</h1>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:</p>
<ul>
<li>Input: <code>nums = [1,2,3,1]</code></li>
<li>Output: <code>4</code></li>
<li>Explanation: <code>Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.</code></li>
</ul>
<p>Example 2:</p>
<ul>
<li>Input: <code>nums = [2,7,9,3,1]</code></li>
<li>Output: <code>12</code></li>
<li>Explanation: <code>Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.</code></li>
</ul>
<p>Constraints:</p>
<pre><code>1 &lt;= nums.length &lt;= 100
0 &lt;= nums[i] &lt;= 400</code></pre>
</section>
<section id="approaches" class="level1">
<h1>Approaches</h1>


</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-find-closest-node-given-2-nodes/</guid>
  <pubDate>Fri, 30 May 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Role of Parallel Computing</title>
  <dc:creator>Hung </dc:creator>
  <link>https://kimhungbui.github.io/programming/parallel-computing/chapter1.html</link>
  <description><![CDATA[ 







 ]]></description>
  <category>parallel</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/parallel-computing/chapter1.html</guid>
  <pubDate>Wed, 07 May 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Count good triplets</title>
  <dc:creator>Hung </dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-count-good-triplets/</link>
  <description><![CDATA[ 




<section id="question" class="level1">
<h1>Question</h1>
<p>Given&nbsp;an&nbsp;array&nbsp;of&nbsp;integers&nbsp;<code>arr</code>,&nbsp;and&nbsp;three&nbsp;integers&nbsp;<code>a</code>,&nbsp;<code>b</code>&nbsp;and&nbsp;<code>c</code>.&nbsp;You&nbsp;need&nbsp;to&nbsp;find&nbsp;the&nbsp;number&nbsp;of&nbsp;good&nbsp;triplets.</p>
<p>A&nbsp;triplet&nbsp;<code>(arr[i], arr[j], arr[k])</code>&nbsp;is&nbsp;<strong>good</strong>&nbsp;if&nbsp;the&nbsp;following&nbsp;conditions&nbsp;are&nbsp;true:</p>
<ul>
<li><code>0 &lt;= i &lt; j &lt; k &lt;&nbsp;arr.length</code></li>
<li><code>|arr[i] - arr[j]| &lt;= a</code></li>
<li><code>|arr[j] - arr[k]| &lt;= b</code></li>
<li><code>|arr[i] - arr[k]| &lt;= c</code></li>
</ul>
<p>Where&nbsp;<code>|x|</code>&nbsp;denotes&nbsp;the&nbsp;absolute&nbsp;value&nbsp;of&nbsp;<code>x</code>.</p>
<p>Return&nbsp;<em>the&nbsp;number&nbsp;of&nbsp;good&nbsp;triplets</em>.</p>
<p><strong>Example&nbsp;1:</strong></p>
<p><strong>Input:</strong> <code>arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3</code> <strong>Output:</strong> 4 <strong>Explanation:</strong>&nbsp;There are 4 good triplets: <code>[(3,0,1), (3,0,1), (3,1,1), (0,1,1)]</code>.</p>
<p><strong>Example&nbsp;2:</strong></p>
<p><strong>Input:</strong> <code>arr = [1,1,2,2,3], a = 0, b = 0, c = 1</code> <strong>Output:</strong> 0 <strong>Explanation:</strong> No triplet satisfies all conditions.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>3 &lt;= arr.length &lt;= 100</code></li>
<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>
<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>
</ul>
</section>
<section id="analysis" class="level1">
<h1>Analysis</h1>
<section id="approach-1-enumeration" class="level3">
<h3 class="anchored" data-anchor-id="approach-1-enumeration">Approach&nbsp;1:&nbsp;Enumeration</h3>
<section id="intuition" class="level4">
<h4 class="anchored" data-anchor-id="intuition">Intuition</h4>
<p>Using&nbsp;<code>O(n3)</code>&nbsp;loops&nbsp;to&nbsp;enumerate&nbsp;all&nbsp;(i,j,k)&nbsp;in&nbsp;sequence,&nbsp;where&nbsp;0≤i&lt;j&lt;k&lt;arr.length,&nbsp;for&nbsp;each&nbsp;set&nbsp;of&nbsp;(i,j,k),&nbsp;determine&nbsp;whether&nbsp;arr[i],&nbsp;arr[j],&nbsp;and&nbsp;arr[k]&nbsp;satisfy&nbsp;the&nbsp;condition.</p>
<p>Finally,&nbsp;calculate&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;all&nbsp;triplets&nbsp;that&nbsp;meet&nbsp;the&nbsp;conditions.</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Solution:</span>
<span id="cb1-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> countGoodTriplets(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, arr: List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>], a: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>, b: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>, c: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>:</span>
<span id="cb1-3">        n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(arr)</span>
<span id="cb1-4">        countGoodTriplets <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb1-5">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n):</span>
<span id="cb1-6">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> j <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, n):</span>
<span id="cb1-7">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">abs</span>(arr[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> arr[j]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> a:</span>
<span id="cb1-8">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> k <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(j <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, n):</span>
<span id="cb1-9">                    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">abs</span>(arr[j] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> arr[k]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> b <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">abs</span>(arr[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> arr[k]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> c:</span>
<span id="cb1-10">                        countGoodTriplets <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb1-11">                        </span>
<span id="cb1-12">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> countGoodTriplets</span></code></pre></div>
</section>
</section>
<section id="approach-2-optimized-enumeration" class="level2">
<h2 class="anchored" data-anchor-id="approach-2-optimized-enumeration">Approach 2: Optimized enumeration</h2>
<p>We need to eliminate one loop or make one of them constant-time.</p>
<p>We could try fixing <code>(j,k)</code> and then counting valid <code>i &lt; j</code>. That <img src="https://latex.codecogs.com/png.latex?O(n%5E2)"> pairs, and if we can count the <img src="https://latex.codecogs.com/png.latex?i">s in <img src="https://latex.codecogs.com/png.latex?O(1)"> each, we down to <img src="https://latex.codecogs.com/png.latex?O(n%5E2)"> total.</p>
<section id="translate-the-i-constraints-into-an-interval" class="level3">
<h3 class="anchored" data-anchor-id="translate-the-i-constraints-into-an-interval">Translate the <img src="https://latex.codecogs.com/png.latex?i">-constraints into an interval</h3>
<p>For a given <img src="https://latex.codecogs.com/png.latex?(j,k)">, the condition on <img src="https://latex.codecogs.com/png.latex?i"> are <img src="https://latex.codecogs.com/png.latex?%7Carr%5Bi%5D%20-%20arr%5Bj%5D%7C%20%5Cleq%20a"> so, <img src="https://latex.codecogs.com/png.latex?arr%5Bi%5D%20%5Cin%20%5Barr%5Bj%5D-a,%20arr%5Bj%5D+a%5D"></p>
<p>and <img src="https://latex.codecogs.com/png.latex?%7Carr%5Bi%5D-arr%5Bk%5D%7C%5Cleq%20c"> so, <img src="https://latex.codecogs.com/png.latex?arr%5Bi%5D%5Cin%5Barr%5Bk%5D-c,%20arr%5Bk%5D+c%5D"></p>
<p>Their intersection is a single interval <img src="https://latex.codecogs.com/png.latex?%5Bl,%20r%5D">. So we just need to count how many prior <img src="https://latex.codecogs.com/png.latex?i%3Cj"> have <img src="https://latex.codecogs.com/png.latex?arr%5Bi%5D%20%5Cin%20%5Bl,%20r%5D">.</p>
</section>
<section id="choose-a-data-structure-for-last-range-count" class="level3">
<h3 class="anchored" data-anchor-id="choose-a-data-structure-for-last-range-count">Choose a data structure for last range-count</h3>
<p>Since <code>arr[i]</code> is small-range, maintain a frequency array <code>freq[0..M]</code> for all seen indices <img src="https://latex.codecogs.com/png.latex?%3Cj">, and its prefix sums <code>sum[v] =</code><img src="https://latex.codecogs.com/png.latex?%5CSigma_%7Bu=0%7D%5Ev%20freq%5Bu%5D"></p>
<p>Then the count in <img src="https://latex.codecogs.com/png.latex?%5Bl,%20r%5D"> is simply <code>sum[r]-sum[l-1]</code> in <img src="https://latex.codecogs.com/png.latex?O(1)">.</p>
</section>
<section id="ensure-the-ij-ordering" class="level3">
<h3 class="anchored" data-anchor-id="ensure-the-ij-ordering">Ensure the <img src="https://latex.codecogs.com/png.latex?i%3Cj"> ordering</h3>
<p>We iterate <img src="https://latex.codecogs.com/png.latex?j"> from 1 to <img src="https://latex.codecogs.com/png.latex?n">. Before handling any <img src="https://latex.codecogs.com/png.latex?(j,%20k)"> pairs, our <code>freq/sum</code> reflects exact indices 1 through <img src="https://latex.codecogs.com/png.latex?j-1">.</p>
<p>For each <img src="https://latex.codecogs.com/png.latex?k%3Ej">, check <img src="https://latex.codecogs.com/png.latex?%7Carr%5Bj%5D%20-%20arr%5Bk%5D%7C%5Cleq%20b">. If it passes, compute <img src="https://latex.codecogs.com/png.latex?%5Bl,%20r%5D"> and do the <img src="https://latex.codecogs.com/png.latex?O(1)"> range-sum query.</p>
<p>After finishing all <img src="https://latex.codecogs.com/png.latex?k"> for this <img src="https://latex.codecogs.com/png.latex?j">, we insert <img src="https://latex.codecogs.com/png.latex?arr%5Bj%5D"> into <code>freq</code> (and update <code>sum</code>), before moving onto <img src="https://latex.codecogs.com/png.latex?j%20+%201">.</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> Solution:</span>
<span id="cb2-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> countGoodTriplets(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, arr: List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>], a: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>, b: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>, c: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>:</span>
<span id="cb2-3">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ans: total count of valid (i,j,k)</span></span>
<span id="cb2-4">        ans <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb2-5">        </span>
<span id="cb2-6">        n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(arr)</span>
<span id="cb2-7">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># total[v] will hold the prefix-sum of frequencies:</span></span>
<span id="cb2-8">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#   total[v] = number of i&lt;j with arr[i] ≤ v</span></span>
<span id="cb2-9">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># we assume arr[i] ∈ [0..1000], so we size total to 1001</span></span>
<span id="cb2-10">        total <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1001</span></span>
<span id="cb2-11"></span>
<span id="cb2-12">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Move j from 0 to n-1</span></span>
<span id="cb2-13">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> j <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n):</span>
<span id="cb2-14">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Pair j with every k&gt;j</span></span>
<span id="cb2-15">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> k <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(j <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, n):</span>
<span id="cb2-16">                <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># First check the |arr[j] - arr[k]| ≤ b constraint</span></span>
<span id="cb2-17">                <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">abs</span>(arr[j] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> arr[k]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> b:</span>
<span id="cb2-18">                    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Compute the interval of allowed arr[i] from j’s constraint</span></span>
<span id="cb2-19">                    lj, rj <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> arr[j] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> a, arr[j] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> a</span>
<span id="cb2-20">                    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Compute the interval of allowed arr[i] from k’s constraint</span></span>
<span id="cb2-21">                    lk, rk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> arr[k] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> c, arr[k] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> c</span>
<span id="cb2-22"></span>
<span id="cb2-23">                    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Intersection [l..r] of the two intervals</span></span>
<span id="cb2-24">                    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># also clamp to [0..1000] to stay in array bounds</span></span>
<span id="cb2-25">                    l <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, lj, lk)</span>
<span id="cb2-26">                    r <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>, rj, rk)</span>
<span id="cb2-27"></span>
<span id="cb2-28">                    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># If the intersection is non-empty, count how many</span></span>
<span id="cb2-29">                    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># prior i&lt;j have arr[i] in [l..r] via prefix sums</span></span>
<span id="cb2-30">                    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> l <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> r:</span>
<span id="cb2-31">                        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> l <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb2-32">                            ans <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> total[r]</span>
<span id="cb2-33">                        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb2-34">                            ans <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> total[r] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> total[l <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]</span>
<span id="cb2-35"></span>
<span id="cb2-36">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># After processing all k for this j, we “add” arr[j] into our</span></span>
<span id="cb2-37">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># prefix-sum structure so that future iterations see it.</span></span>
<span id="cb2-38">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We do this by incrementing total[v] for all v ≥ arr[j].</span></span>
<span id="cb2-39">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># That way total[v] remains = # of arr[i] ≤ v for i&lt;next j.</span></span>
<span id="cb2-40">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> v <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(arr[j], <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1001</span>):</span>
<span id="cb2-41">                total[v] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb2-42"></span>
<span id="cb2-43">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> ans</span></code></pre></div>


</section>
</section>
</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-count-good-triplets/</guid>
  <pubDate>Tue, 15 Apr 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Maximum subarray</title>
  <dc:creator>Hung </dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-maximum-subarray/</link>
  <description><![CDATA[ 




<section id="question" class="level1">
<h1>Question</h1>
<p>Given an integer array nums, find the subarray with the largest sum, and return its sum.</p>
<p>Example 1:</p>
<p>Input: nums = <code>[-2,1,-3,4,-1,2,1,-5,4]</code> Output: 6 Explanation: The subarray <code>[4,-1,2,1]</code> has the largest sum 6. Example 2:</p>
<p>Input: nums = <code>[1]</code> Output: 1 Explanation: The subarray <code>[1]</code> has the largest sum 1. Example 3:</p>
<p>Input: <code>nums = [5,4,-1,7,8]</code> Output: 23 Explanation: The subarray <code>[5,4,-1,7,8]</code> has the largest sum 23.</p>
<p>Constraints:</p>
<p><code>1 &lt;= nums.length &lt;= 105</code> <code>-104 &lt;= nums[i] &lt;= 104</code></p>
<p>Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
</section>
<section id="answer" class="level1">
<h1>Answer:</h1>
<section id="brute-force" class="level2">
<h2 class="anchored" data-anchor-id="brute-force">Brute force</h2>
<pre><code>    # brute force approach

    # find all left, and right 
    # cal sum of each
    # return max
    # T.C: O(n^2)</code></pre>
<div id="64b8ab30" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> typing <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> List</span>
<span id="cb2-2"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> maxSubArray(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, nums: List[<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>:</span>
<span id="cb2-3">    left, ans <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, nums[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb2-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> left <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums)):</span>
<span id="cb2-5">        cur <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb2-6">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> right <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(left, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums)):</span>
<span id="cb2-7">            cur <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> nums[right]</span>
<span id="cb2-8">            ans <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(ans, cur)</span>
<span id="cb2-9"></span>
<span id="cb2-10">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> ans</span></code></pre></div>
</div>
<p>it will TLE.</p>


</section>
</section>

 ]]></description>
  <category>leetcode</category>
  <category>programming</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-maximum-subarray/</guid>
  <pubDate>Fri, 04 Apr 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Disjoint Set Union</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/disjoint-set-union/</link>
  <description><![CDATA[ 




<p>This data structure provides the following capabilities. We are given several elements, each of which is a separate set. A DSU will have an operation to <strong>combine any two sets</strong>, and it will be able to <strong>tell in which set a specific element is</strong>. The classical version also introduces a third operation, it can <strong>create a set from a new element</strong>.</p>
<p>Thus the basic interface of this data structure consists of only three operations: - <code>make_set()</code> - create a new set consisting of the new element <code>v</code>. - <code>union_sets(a, b)</code> - merges the two specified sets (the set in which the element <code>a</code> is located, and the set in which the element <code>b</code> is located). - <code>find_set(v)</code> - return the representative (also called leader) of the set that contains the element <code>v</code>. This representative is an element of its corresponding set. It is selected in each set by the data structure itself (and can change over time, namely after <code>union_sets</code> call). This representative can be used to check if two elements are part of the same set or not. <code>a</code> and <code>b</code> are exactly in the same set, if <code>find_set(a) == find_set(b)</code>. Otherwise they are in different sets.</p>
<p>As described on more detail later, the data structure allows us to do each of these operations in almost <img src="https://latex.codecogs.com/png.latex?O(1)"> time on average.</p>
<p>Also in one of the subsections an alternative structure of a DSU is explained, which achieves a slower average complexity of <img src="https://latex.codecogs.com/png.latex?O(%5Clog%20n)">, but can be more powerful than the regular DSU structure.</p>
<section id="build-an-efficient-data-structure" class="level1">
<h1>Build an efficient data structure</h1>
<p>We will store the sets in the form of <strong>trees</strong>: each tree will correspond to one set. And the root of the tree will be the representative/leader of the set.</p>
<p>In the following image we can see the representative of such trees.</p>
<p>![[DSU_example.png]] In the beginning, every element starts as a single set, there fore each vertex is its own tree. Then we combine the set containing the element 1 and the et containing the element 2. Then we combine the set containing the element 3 and the set containing the element 4. And in the last step, we combine the set containing the element 1 and the set containing the element 3.</p>
<p>For the implementation this means that we will have to maintain an array <code>parent</code> that stores a reference to its immediate ancestor in the tree.</p>
<section id="naive-implementation" class="level2">
<h2 class="anchored" data-anchor-id="naive-implementation">Naive implementation</h2>
<p>We can already write the first implementation of the Disjoint Set Union data structure. It will be pretty inefficient at first, but later we can improve it using two optimizations, so that it will take nearly constant time for each function call.</p>
<p>As we said, all the information about the sets of elements will be kept in an array <code>parent</code>.</p>
<p>To create a new set (operation <code>make_set(v)</code>), we simply create a tree with root in the vertex <code>x</code>, meaning that it is its own ancestor.</p>
<p>To combine two sets (operation <code>union_sets(a, b)</code>), we first find the representative of the set in which <code>a</code> is located, and the representative of the set in which <code>b</code> is located. If the representatives are identical, that we have nothing to do, the sets are already merged. Otherwise, we can simply specify that one of the representatives is the parent of the other representative - thereby combining the two trees.</p>
<p>Finally the implementation of the find representative function (operation <code>find_set(v)</code>): we simply climb the ancestors of the vertex <code>v</code> until we reach the root, i.e.&nbsp;a vertex such that the reference to the ancestor leads to itself. This operation is easily implemented recursively.</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode c++ code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">void</span> make_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb1-2">    parent<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-3"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb1-4"></span>
<span id="cb1-5"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> find_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb1-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>v <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> parent<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">])</span></span>
<span id="cb1-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-8">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> find_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>parent<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]);</span></span>
<span id="cb1-9"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb1-10"></span>
<span id="cb1-11"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">void</span> union_sets<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb1-12">    a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> find_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb1-13">    b <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> find_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb1-14">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span id="cb1-15">        parent<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb1-16"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
<p>However this implementation is inefficient. It is easy to construct an example, so that the trees degenerate into long chains. In that case each call <code>find_set(v)</code> can take <img src="https://latex.codecogs.com/png.latex?O(n)"> time.</p>
<p>This is far away from the complexity that we want to have (nearly constant time). Therefore we will consider two optimizations that will allow to significantly accelerate the work.</p>
</section>
<section id="path-compression-optimization" class="level2">
<h2 class="anchored" data-anchor-id="path-compression-optimization">Path compression optimization</h2>
<p>This optimization is designed for speeding up <code>find_set</code>.</p>
<p>If we call <code>find_set()</code> for some vertex <code>x</code>, we actually find the representative <code>p</code> for all vertices that we visit on the path between <code>v</code> and the actually representative <code>p</code>. The trick is to make the paths for all those nodes shorter, by setting the parent of each visited vertex directly to <code>p</code>.</p>
<p>We can see the operation in the following image. On the left there is a tree, and on the right side there is the compressed tree after calling <code>find_set(7)</code>, which shortens the paths for the visited node 7, 5, 3 and 2.</p>
<p>![[DSU_path_compression.png]]</p>
<p>The new implementation of <code>find_set</code> is as follows:</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> find_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb2-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>v <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> parent<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">])</span></span>
<span id="cb2-3">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb2-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> parent<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> find_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>parent<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]);</span></span>
<span id="cb2-5"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
<p>The simple implementation does what was intended: first find the representative of the set (root vertex), and then in the process of stack unwinding the visited nodes are attached directly to the representative.</p>
<p>This simple modification of the operation already achieves the time complexity <img src="https://latex.codecogs.com/png.latex?O(%5Clog%20n)"> per call on average (here without proof). There is a second modification, that will make it even faster.</p>
</section>
<section id="union-by-size-rank" class="level2">
<h2 class="anchored" data-anchor-id="union-by-size-rank">Union by size / rank</h2>
<p>In this optimization we will change the <code>union_set</code> operation. To be precise, we will change which tree gets attached to the other one. In the naive implementation the second tree always got attached to the first one. In practice that can lead to trees containing chains of length <img src="https://latex.codecogs.com/png.latex?O(n)">. With this optimization we will avoid this by choosing very carefully which tree gets attached.</p>
<p>There are many possible heuristic that can be used. Most popular are the following two approaches: In the first approach we use the size of the trees as rank, and in the second one we use the depth of the tree (more precisely, the upper bound on the tree depth, because the depth will get smaller when applying path compression).</p>
<p>In both approaches the essence of the optimization is the same: we attach the tree with the lower rank to the one with the bigger rank.</p>
<p>Here is the implementation of union by size:</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">void</span> make_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb3-2">    parent<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb3-3">    size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb3-4"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb3-5"></span>
<span id="cb3-6"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">void</span> union_sets<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">){</span></span>
<span id="cb3-7">    a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> find_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb3-8">    b <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> find_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb3-9">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb3-10">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">])</span></span>
<span id="cb3-11">            swap<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span> b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb3-12">        parent<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb3-13">        size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">];</span></span>
<span id="cb3-14">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb3-15"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
<p>and here is the implementation of union by rank based on the depth of the trees:</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">void</span> make_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb4-2">    parent<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-3">    rank<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-4"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb4-5"></span>
<span id="cb4-6"><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">void</span> union_sets<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">int</span> b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb4-7">    a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> find_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb4-8">    b <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> find_set<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb4-9">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb4-10">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>rank<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> rank<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">])</span></span>
<span id="cb4-11">            swap<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span> b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">);</span></span>
<span id="cb4-12">        parent<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span></span>
<span id="cb4-13">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>rank<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> rank<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>b<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">])</span></span>
<span id="cb4-14">            rank<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>a<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]++;</span></span>
<span id="cb4-15">    <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb4-16"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div>
<p>Both optimizations are equivalent in terms of time and space complexity. So in practice we can use any of them.</p>
</section>
<section id="time-complexity" class="level2">
<h2 class="anchored" data-anchor-id="time-complexity">Time complexity</h2>
<p>As mentioned before, if we combine both optimizations - path compression with union by size / rank - we will reach nearly constant time queries. It turns out, that the final amortized complexity is <img src="https://latex.codecogs.com/png.latex?O(%5Calpha(n))">, where <img src="https://latex.codecogs.com/png.latex?%5Calpha%20(n)"> is the inverse Ackermann function, which grows very slowly. In fact it grows so lowly, that it doesn’t exceed 4 for all reasonable <img src="https://latex.codecogs.com/png.latex?n"> (approximately <img src="https://latex.codecogs.com/png.latex?n%3C10%5E%7B600%7D">).</p>
<p>Amortized complexity is the total time per operation, evaluated over a sequence of multiple operations. The idea is to guarantee the total time of the entire sequence, while allowing single operations to be much slower than the amortized time. E.g. in our case a single call might take <img src="https://latex.codecogs.com/png.latex?O(%5Clog%20n)"> in the worst case, but if we do <img src="https://latex.codecogs.com/png.latex?m"> such calls back to back we will end up with an average time of <img src="https://latex.codecogs.com/png.latex?O(%5Calpha%20(n))">.</p>
<p>We will also not present a proof for this time complexity, since it is quite long and complicated.</p>
<p>Also, it’s worth mentioning that DSU with union by size / rank, but without path compression works in <img src="https://latex.codecogs.com/png.latex?O(%5Clog%20n)"> time per query.</p>
</section>
<section id="linking-by-index-coin-flip-linking" class="level2">
<h2 class="anchored" data-anchor-id="linking-by-index-coin-flip-linking">Linking by index / coin-flip linking</h2>
<p>Both union by rank and union by size require that we store additional data for each set, and maintain these values during each union operation. There exist also a randomized algorithm, that simplifies the union operation a little bit: linking by index.</p>
<p>We assign each set a random value called the index, and we attach the set with the smaller index to the one with the larger one. It is likely that a bigger set will have a bigger than the smaller set, therefore this operation is closely related to union by size. In fact it can be proven, that this operation has the same time complexity as union by size. However in practice it is slightly slower than union by size.</p>


</section>
</section>

 ]]></description>
  <category>programming</category>
  <category>data structure</category>
  <guid>https://kimhungbui.github.io/programming/disjoint-set-union/</guid>
  <pubDate>Fri, 21 Mar 2025 00:00:00 GMT</pubDate>
  <media:content url="https://kimhungbui.github.io/programming/disjoint-set-union/dundee.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Minimum Cost Walk in Weighted Graph</title>
  <dc:creator>Kim Hung Bui</dc:creator>
  <link>https://kimhungbui.github.io/programming/leetcode-minimum-cost-walk-in-weight-graph/</link>
  <description><![CDATA[ 




<section id="question" class="level1">
<h1>Question</h1>
<p>There is an undirected weighted graph with n vertices labeled from 0 to n - 1.</p>
<p>You are given the integer n and an array edges, where edges[i] = [ui, vi, wi] indicates that there is an edge between vertices ui and vi with a weight of wi.</p>
<p>A walk on a graph is a sequence of vertices and edges. The walk starts and ends with a vertex, and each edge connects the vertex that comes before it and the vertex that comes after it. It’s important to note that a walk may visit the same edge or vertex more than once.</p>
<p>The cost of a walk starting at node u and ending at node v is defined as the bitwise AND of the weights of the edges traversed during the walk. In other words, if the sequence of edge weights encountered during the walk is w0, w1, w2, …, wk, then the cost is calculated as w0 &amp; w1 &amp; w2 &amp; … &amp; wk, where &amp; denotes the bitwise AND operator.</p>
<p>You are also given a 2D array query, where query[i] = [si, ti]. For each query, you need to find the minimum cost of the walk starting at vertex si and ending at vertex ti. If there exists no such walk, the answer is -1.</p>
<p>Return the array answer, where answer[i] denotes the minimum cost of a walk for query i.</p>
<p>Example 1:</p>
<p>Input: <code>n = 5</code>, edges = <code>[[0,1,7],[1,3,7],[1,2,1]]</code>, query = <code>[[0,3],[3,4]]</code></p>
<p>Output: <code>[1,-1]</code></p>
<p>Explanation:</p>
<p>To achieve the cost of 1 in the first query, we need to move on the following edges: 0-&gt;1 (weight 7), 1-&gt;2 (weight 1), 2-&gt;1 (weight 1), 1-&gt;3 (weight 7).</p>
<p>In the second query, there is no walk between nodes 3 and 4, so the answer is -1.</p>
<p>Example 2:</p>
<p>Input: n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]</p>
<p>Output: [0]</p>
<p>Explanation:</p>
<p>To achieve the cost of 0 in the first query, we need to move on the following edges: 1-&gt;2 (weight 1), 2-&gt;1 (weight 6), 1-&gt;2 (weight 1).</p>
<p>Constraints:</p>
<pre><code>2 &lt;= n &lt;= 105
0 &lt;= edges.length &lt;= 105
edges[i].length == 3
0 &lt;= ui, vi &lt;= n - 1
ui != vi
0 &lt;= wi &lt;= 105
1 &lt;= query.length &lt;= 105
query[i].length == 2
0 &lt;= si, ti &lt;= n - 1
si != ti</code></pre>
</section>
<section id="analysis" class="level1">
<h1>Analysis</h1>
<p>Let’s determine when the answer to a query is <code>-1</code>. This happens when no walk exists between the two nodes, meaning they belong to different connected components.</p>
<p>Now, suppose the two nodes belong to the same connected component. What is the minimum cost of a walk connecting them? As mentioned, the optimal walk includes as many edges as possible. Since revisiting an edge does not affect the total score, we can freely traverse the edges of the component, meaning that we can move back and forth to reach all of them. Therefore, the best way to achieve the lowest cost is to visit every edge in the component.</p>
<p>To efficiently find and process the connected components of the graph, we use the Disjoint Set (Union-Find) data structure. When we Union two nodes, we merge their entire groups, as now a path exists between every node in one group and every node in the other. To maintain efficiency, the root of the larger group is chosen as the representative of the merge group. This minimizes the time needed for future Find operations by reducing the number of steps required to reach the current representative.</p>


</section>

 ]]></description>
  <category>programming</category>
  <category>data structure</category>
  <category>DSU</category>
  <guid>https://kimhungbui.github.io/programming/leetcode-minimum-cost-walk-in-weight-graph/</guid>
  <pubDate>Fri, 21 Mar 2025 00:00:00 GMT</pubDate>
  <media:content url="https://kimhungbui.github.io/programming/leetcode-minimum-cost-walk-in-weight-graph/dundee.jpg" medium="image" type="image/jpeg"/>
</item>
</channel>
</rss>
